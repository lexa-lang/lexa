import exnlist
import exndequeue
import immutable/option


interface Process {
  def yield(): Unit
  def exit(): Nothing
  def fork { p: () => Unit }: Unit
}

interface Tick {
  def tick(): Unit
}

interface Exn {
  def throw(): Nothing
}

def scheduler { prog: => Unit / Process }: Unit / Tick = region this {
  var queue: Dequeue[() => Unit at {this, prog}] in this = emptyQueue();

  def run(): Unit = 
    try {
      queue.popBack match {
        case (k, q) =>
          queue = q
          k();
          run()
      }
    } with NoSuchElementException {
      def throwNSE() = ()
    }
  try { prog() } with Process {
    def yield() = {
      queue = queue.pushFront(fun() { resume(()) })
    }
    def fork() /* {{() => Unit} => Unit} => Unit */ = {
      queue = queue
        .pushFront(fun() { resume { {prog: () => Unit} => prog() /* FIX do abort() */ } })
        .pushFront(fun() { resume { {prog: () => Unit} => () } })
    }
    def exit() /* Nothing => Unit */ = ()
  }

  run()
}

def main() = {
  var a = 0;
  println("Example 1")
  try { 
    scheduler {
      do fork {
        println("hello 1")
        do yield()
        println(1)
        do yield()
        println(2)
        do tick()
        do exit() // FIX this is crucial since fork is not implemented correctly
        println(3)
      }
      println("hello 2")
      do yield()
      println(4)
      do yield()
      println(5)
      do yield()
      println(6)
    }
  } with Tick {
    def tick() = {
      a = a + 1;
      resume( () );
    }
  }
}