import immutable/dequeue
import immutable/option
import text/string
import io/args

interface Tick {
  def tick(): Unit
}

interface Process {
  def yield(): Unit
  def exit(): Nothing
  def fork { p: () => Unit / Process }: Boolean
}

extern pure def cast[T, R](x : T): R =
  "${x}"


def scheduler { prog: => Unit / Process } = region this {
  var queue: Dequeue[() => Unit at {this, prog}] in this = emptyQueue();

  def runnext(): Unit = queue.popFront match {
    case None() => ()
    case Some((k, q)) =>
      queue = q
      k()
  }

  def spawn(prog1: () => Unit / Process at {this, prog} ): Unit = {
    try { prog1() } with Process {
      def yield() = {
        queue = queue.pushFront(fun() { resume(()) })
        runnext()
      }
      def fork() = {
        queue = queue.pushFront(fun() { resume { {_: () => Unit / Process } => false } })
        resume { {p: () => Unit / Process } => spawn(cast(box p)); true } 
      }
      def exit() = ()
    }
    runnext()
  }

  spawn(prog)
}

def run(n_yields: Int): Int = {
  val n_jobs = 10;
  var c = 0;
  try {
    def job(): Unit / Process = {
      var i = 0;
      while (i < n_yields) {
        do yield();
        i = i + 1
      }
    }
    def entry(): Unit / Process = {
      var i = 0;
      while (i < n_jobs) {
        if (do fork {job(); do tick()}) {
          do exit()
        }
        i = i + 1
      }
    };
    scheduler {
      entry
    };
  } with Tick {
    def tick() = {
      c = c + 1;
      resume( () );
    }
  }
  c
}

def main() = commandLineArgs() match {
  case Nil() => println(run(1000000))
  case Cons(x, Nil()) => toInt(x) match {
    case Some(i) => println(run(i))
    case _ => println("Unexpected non-integer(s) '" ++ show(x) ++ "'")
  }
  case other => println("Expects zero or one argument, not '" ++ show(size(other)) ++ "'")
}