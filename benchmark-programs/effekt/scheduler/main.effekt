import exnlist
import exndequeue
import immutable/option
import io/args
import text/string

interface Tick {
  def tick(): Unit
}

interface Process {
  def yield(): Unit
  def exit(): Nothing
  def fork { newjob: () => Unit }: Unit
}

def scheduler { prog: => Unit / Process }: Unit / Tick = region this {
  var queue: Dequeue[() => Unit at {this, prog}] in this = emptyQueue();

  def driver(): Unit = 
    try {
      queue.popBack match {
        case (k, q) =>
          queue = q
          k();
          driver()
      }
    } with NoSuchElementException {
      def throwNSE() = ()
    }
  try { prog() } with Process {
    def yield() = {
      queue = queue.pushFront(fun() { resume(()) })
    }
    def fork() /* {{() => Unit} => Unit} => Unit */ = {
      queue = queue
        .pushFront(fun() { resume { {newjob: () => Unit} => newjob() /* FIX do abort() */ } })
        .pushFront(fun() { resume { {newjob: () => Unit} => () } })
    }
    def exit() /* Nothing => Unit */ = ()
  }

  driver()
}

def jobs(n_jobs: Int): Unit / {Process, Tick} = {
  def job(): Unit = {
    do yield ()
    do exit() // FIX this is crucial since fork is not implemented correctly
  }
  var i = 0;
  while (i < n_jobs) {
    do tick()
    do fork {job}
    i = i + 1
  }
}

def run(n: Int): Int = {
  var i = 0;
  var a = 0;
  while (i < 1000) {
    try { 
      scheduler { jobs(n) }
    } with Tick {
      def tick() = {
        a = a + 1;
        resume( () );
      }
    }
    i = i + 1
  }
  a
}

def main() = commandLineArgs() match {
  case Nil() => println(run(10))
  case Cons(x, Nil()) => toInt(x) match {
    case None() => println("Unexpected non-integer '" ++ show(x) ++ "'")
    case Some(i) => println(run(i))
  }
  case other => println("Expects zero or one argument, not '" ++ show(size(other)) ++ "'")
}
