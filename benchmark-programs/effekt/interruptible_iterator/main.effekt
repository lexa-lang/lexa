
import immutable/list
import immutable/option
import text/string
import io/args

def ignoring0[E] { prog: => List[Int] / Exception[E] }: List[Int] =
  try { prog() } with Exception[E] { def raise(exception: E, msg: String) = [] }

effect Yield(value: Int): Unit / { Replace, Behead }
effect Replace(value: Int): Unit
effect Behead(): Unit

def range(start: Int, size: Int): List[Int] = {
  build(size) { i => start + i }
}

def iter(l: List[Int]): List[Int] / { Yield, Behead } =  {

    def loop(it: List[Int]): List[Int] / { Yield, Behead } = ignoring0[EmptyList] {
        var hd = it.head;
        var tl = it.tail;
        var beheadCount = 0;
        try { 
            do Yield(hd); 
        } with Replace { n =>
            hd = n;
            resume(())
        }
        val newtl =
            if (not(isEmpty(tl))) {
                try {
                    loop(tl)
                } with Behead {
                    beheadCount = beheadCount + 1;
                    resume(())
                }
            } else {
                []
            }
        Cons(hd, drop(newtl, beheadCount))
    }
    loop(l)
}

def run(n: Int) = ignoring[EmptyList] {
    var lst = range(0-n, 2*n);
    var beheadCount = 0;
    var res = try { lst.iter }
    with Yield { x =>
      resume { if (x < 0) do Behead() else do Replace(x * 2) }
    }
    with Behead { () =>
        beheadCount = beheadCount + 1;
        resume(())
    };
    res = drop(res, beheadCount)
    println(sum(res))
}

def main() = commandLineArgs() match {
  case Nil() => run(10)
  case Cons(x, Nil()) => toInt(x) match {
    case Some(i) => run(i)
    case _ => println("Unexpected non-integer(s) '" ++ show(x) ++ "'")
  }
  case other => println("Expects zero or one argument, not '" ++ show(size(other)) ++ "'")
}