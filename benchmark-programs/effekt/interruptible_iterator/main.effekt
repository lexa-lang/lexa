import list
import args
import bench

def ignoring0[E] { prog: => List[Int] / Exception[E] }: List[Int] =
  try { prog() } with Exception[E] { def raise(exception: E, msg: String) = [] }

effect Yield(value: Int): Unit / { Replace, Behead }
effect Replace(value: Int): Unit
effect Behead(): Unit

def range(lo: Int, hi: Int): List[Int] = {
  build(hi-lo+1) { i => lo + i }
}

def iter(l: List[Int]): List[Int] / { Yield, Behead } =  {

    def loop(it: List[Int]): List[Int] / { Yield, Behead } = {
        var out: List[Int] = Nil();
        ignore[MissingValue] {
          var hd = it.head;
          var tl = it.tail;
          var beheaded = false;
          try { 
              do Yield(hd); 
          } with Replace { n =>
              hd = n;
              resume(())
          }
          val newtl =
              if (isEmpty(tl)) {
                  []
              } else {
                  try {
                      loop(tl)
                  } with Behead {
                      beheaded = true
                      resume(())
                  }
              }
          if (beheaded) {
              out = Cons(hd, newtl.drop(1))
          } else {
              out = Cons(hd, newtl)
          }
        }
        out
    }
    loop(l)
}

def run(n: Int) : Int = {
    var lst = range(0-n, n);
    var beheaded = false;
    var res = try { lst.iter }
        with Yield { x =>
        resume { if (x < 0) do Behead() else do Replace(x * 2) }
        }
        with Behead { () =>
            beheaded = true;
            resume(())
        };
    sum(if (beheaded) res.drop(1) else res)
}

def step(i: Int, acc: Int, n_jobs: Int): Int = {
  if (i == 0) {
    acc
  } else {
    step(i - 1, run(n_jobs)+acc, n_jobs)
  }
}

def repeat(n_jobs: Int): Int = {
  // NB: The loop count is reduced from 1000
  step(1, 0, n_jobs)
}

def main() = ignore[WrongFormat] {commandLineArgs() match {
  case Nil() => println("Expects one argument")
  case Cons(x, Cons(y, Nil())) => 
    println("Measuring internal running time")
    val t = timed{ repeat(x.toInt); () }
    println("Nanosecond used: " ++ show(t))
  case Cons(x, Nil()) =>
    val r = repeat(x.toInt)
    println(r)
  case other => println("Expects one argument, not '" ++ show(size(other)) ++ "'")
}
}
