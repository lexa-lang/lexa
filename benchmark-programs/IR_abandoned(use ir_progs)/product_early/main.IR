
effect Abort {
  dcl done
}

def product(xs, abort_stub) {
    if (~listIsEmpty(xs)) {
        0
    } else {
        let y = ~listHead(xs) in {
        let ys = ~listTail(xs) in {
            if (y == 0) {
                raise abort_stub.done 0
            } else {
                y * product(ys)
            }
        }
        }
    }
}

def enumerate(i) {
    if (i < 0) {
        ~listEnd()
    } else {
        ~listNode(i, enumerate(i - 1))
    }
}

obj abort(env) {
    exc done(r) {
        r
    }
}

def body(env, abort_stub) {
    product(env[0], abort_stub)
}

def runProduct(xs) {
    handle <xs>
        body
    with abort: Abort;
}

def loop(xs, i, a) {
    if (i == 0) {
        a
    } else {
        loop(xs, i - 1, a + runProduct(xs))
    }
}

def run(n) {
    let xs = enumerate(1000) in {
        loop(xs, n, 0)
    }
}

def main() = {
    ~printInt(run(~readInt()))
}