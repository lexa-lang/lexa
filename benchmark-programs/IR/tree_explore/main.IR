

effect Choose {
  dcl choose
}

def operator(x, y) {
    {~mathAbs(x - (503 * y) + 37)} % 1009
}

def make(n) {
    if (n == 0) {
        ~treeLeaf()
    } else {
        let t = make(n - 1) in {
            ~treeNode(t, n, t)
        }
    }
}

def explore(state, tree, choose_stub) {
    if (~treeIsEmpty(tree)) {
        state[0]
    } else {
      let next = { if (raise choose_stub.choose 0) { ~treeLeft(tree) } else { ~treeRight(tree) } } in {
          state[0] := operator(state[0], ~treeValue(tree));
          operator(~treeValue(tree), explore(state, next, h))
      }
    }
}

def paths(state, tree) {
    handle <state, tree>
        fn(env, choose_stub) {
            ~listNode({explore({env[0]}, {env[1]}, choose_stub)}, 
                     {~listEnd()})
        }
    with Choose {
        general choose(env, _, k) {
            ~listAppend( { throw k True }, { throw k False } )
        }
    }
}

def loop(state, tree, i) {
    if (i == 0) {
        state[0]
    } else {
        state[0] := ~listMax({paths(state, tree)});
        loop(state, tree, i - 1)
    }
}

def run(n) {
    let tree = make(n) in {
    let state = newref <0> in {
        loop(state, tree, n)
    }
    }
}

def main() = {
    ~printInt(run(~readInt()))
}