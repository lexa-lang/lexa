def job(env, sch_stub) {
    {env[0]}[0] := {env[0]}[0] + 1;
    raise sch_stub.yield 0;
    {env[0]}[0] := {env[0]}[0] + 1;
}

def loop(i, job_closure, sch_stub) {
    if (i == 0) {
        0
    } else {
        raise sch_stub.fork job_closure;
        loop(i - 1, job_closure, sch_stub)
    }
}

def entry(env, sch_stub) {
    let n = env[0] in {
    let job_closure = env[1] in {
        loop(n, job_closure, sch_stub)
    }
    }
}

def suspend(job_queue, k) {
    queueEnq(job_queue, k)
}

def runnext(job_queue) {
    if (queueIsEmpty(job_queue)) {
        0
    } else {
        let k = queueDeq(job_queue) in {
            throw k 0
        }
    }
}

def spawn(job_closure, suspend_closure, runnext_closure) {
    handle <job_closure, suspend_closure, runnext_closure>
        fn(env, sch_stub) {
            let job_closure = env[0] in {
            let job_func = job_closure[0] in {
            let job_env = job_closure[1] in {
                job_func(job_env)
            }
            }
            }
        }
    with Scheduler {
        general yield(env, _, k) {
            let suspend_closure = env[1] in {
            let suspend_func = suspend_closure[0] in {
            let job_queue = suspend_closure[1] in {
                suspend_func(job_queue, k)
            }
            }
            };
            let runnext_closure = env[2] in {
            let runnext_func = runnext_closure[0] in {
            let job_queue = runnext_closure[1] in {
                runnext_func(job_queue)
            }
            }
            }
        }
        general fork(env, newjob_closure, k) {
            let suspend_closure = env[1] in {
            let suspend_func = suspend_closure[0] in {
            let suspend_env = suspend_closure[1] in {
                suspend_func(suspend_env, k)
            }
            }
            };
            spawn(newjob_closure, {env[1]}, {env[2]})
        }
    };
    let runnext_func = runnext_closure[0] in {
    let job_queue = runnext_closure[1] in {
        runnext_func(job_queue)
    }
    }
}

def startScheduler(init_closure) {
    let job_queue = queueMake () in {
    let suspend_closure = newref <suspend, job_queue> in {
    let runnext_closure = newref <runnext, job_queue> in {
        spawn(init_closure, suspend_closure, runnext_closure)
    }
    }
    }
}

def run(n) {
    let state = newref <0> in {
    let job_closure = newref <job, state> in {
    let entry_env = newref <n, job_closure> in {
    let entry_closure = newref <entry, entry_env> in {
        startScheduler(entry_closure);
        state[0]
    }
    }
    }
    }
}


def main() = {
    ~printInt(run(~readInt()))
}