
effect Abort {
  dcl done
}

def product(xs, abort_stub) {
    if (~listIsEmpty(xs)) {
        0
    } else {
        let y = ~listHead(xs) in {
        let ys = ~listTail(xs) in {
            if (y == 0) {
                raise abort_stub.done 0
            } else {
                y * product(ys)
            }
        }
        }
    }
}

def enumerate(i) {
    if (i < 0) {
        ~listEnd()
    } else {
        ~listNode(i, enumerate(i - 1))
    }
}

def runProduct(xs) {
    handle <xs>
        fn(env, abort_stub) {
            product({env[0]}, abort_stub)
        }
    with Abort {
        abortive done(env, r) {
            r
        }
    }
}

def loop(xs, i, a) {
    if (i == 0) {
        a
    } else {
        loop(xs, i - 1, a + runProduct(xs))
    }
}

def run(n) {
    let xs = enumerate(1000) in {
        loop(xs, n, 0)
    }
}

def main() = {
    ~printInt(run(~readInt()))
}