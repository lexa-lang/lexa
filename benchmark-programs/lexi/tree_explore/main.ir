effect Choice {
  dcl choose
}

def operator(x, y) {
    val sub1 = x;
    val sub2 = 503 * y;
    val plus1 = sub1 - sub2;
    val plus2 = 37;
    val arg = plus1 + plus2;
    val mod1 = ~mathAbs(arg);
    mod1 % 1009
}

def make(n) {
    val cond = n == 0;
    if cond then
        ~treeLeaf()
    else
        val arg = n - 1;
        val t = make(arg);
        ~treeNode(n, t, t)
}

def explore(state, tree, choice_stub) {
    val cond = ~treeIsEmpty(tree);
    if cond then
        state[0]
    else
        val next = 
            val cond = raise choice_stub.choose 0;
            if cond then 
                ~treeLeft(tree)
            else
                ~treeRight(tree)
        ;
        val arg1 = state[0];
        val arg2 = ~treeValue(tree);
        val v = operator(arg1, arg2);
        val _ = state[0] := v;
        val arg3 = explore(state, next, choice_stub);
        operator(arg2, arg3)
}

obj choice(env) {
    hdl_s choose(_, k) {
        val arg1 = resume k true;
        val arg2 = resume_final k false;
        ~listAppend(arg1, arg2)
    }
}

def body(env, choice_stub) {
    val arg1 = env[0];
    val arg2 = env[1];
    val arg3 = explore(arg1, arg2, choice_stub);
    val arg4 = ~listEnd();
    ~listNode(arg3, arg4)
}

def paths(state, tree) {
    handle <state, tree>
        body
    with choice: Choice
}

def loop(state, tree, i) {
    val cond = i == 0;
    if cond then
        state[0]
    else
        val arg1 = paths(state, tree);
        val v = ~listMax(arg1);
        val _ = state[0] := v;
        val arg2 = i - 1;
        loop(state, tree, arg2)
}

def run(n) {
    val tree = make(n);
    val state = newref <0>;
        loop(state, tree, 10)
}

def main() {
    val n = ~readInt();
    val res = run(n);
    val _ = ~printInt(res);
    0
}