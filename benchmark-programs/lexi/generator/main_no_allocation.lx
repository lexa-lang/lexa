effect Yield {
    dcl yield
}

type tree = 
    | Leaf
    | Node of int * tree * tree

type generator =
    | Empty
    | Thunk of int * int

def make(n) {
    if n == 0 then
        Leaf
    else
        val t = make(n - 1);
        Node(n, t, t)
}

def iterate(t, yield_stub) {
    match t with
    | Leaf -> { 0 }
    | Node (value, left, right) -> {
        iterate(left, yield_stub);
        raise yield_stub.yield(value);
        iterate(right, yield_stub)
    }
}

def generate(f, x_store, thunk_store) {
    handle {
        f(yield_stub);
        1
    } with yield_stub: Yield {
        hdl_1 yield(x, k) {
            x_store[0] := x;
            thunk_store[0] := k;
            0
        }
    }
}

def sum(a, g, x_store, thunk_store) {
    if g == 1 then
        a
    else
        sum(x_store[0] + a, resume_final (thunk_store[0]) 0, x_store, thunk_store)
}

def run(n) {
    val x_store = newref{0};
    val thunk_store = newref{0};
    val f = fun(yield_stub) { iterate(make(n), yield_stub) };
    sum(0, generate(f, x_store, thunk_store), x_store, thunk_store)
}

def main() {
    ~printInt(run(~readInt()));
    0
}