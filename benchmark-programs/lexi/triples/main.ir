effect Choice {
    dcl flip
    dcl fail
}

def choice(n, choice_stub) {
    val cond = n < 1;
    if cond then
        raise choice_stub.fail 0
    else
        val cond = raise choice_stub.flip 0;
        if cond then
            n
        else
            val arg = n - 1;
            choice(arg, choice_stub)
}

def triple(n, s, choice_stub) {
    val i = choice(n, choice_stub);
    val arg = i - 1;
    val j = choice(arg, choice_stub);
    val arg = j - 1;
    val k = choice(arg, choice_stub);
    val temp = i + j;
    val sum = temp + k;
    val cond = sum == s;
    if cond then
        hash(i, j, k)
    else
        raise choice_stub.fail 0
}

def body(env, choice_stub) {
    val n = env[0];
    val s = env[1];
    triple(n, s, choice_stub)
}

obj choice(env) {
    exc fail(_) {
        0
    }

    hdl_s flip(_, k) {
        val p1 = resume k true;
        val p2 = resume_final k false;
        val mod1 = p1 + p2;
        val mod2 = 1000000007;
        mod1 % mod2
    }
}

def run(n, s) {
    handle <n, s>
        body
    with choice: Choice
}

def hash(a,b,c) {
    val plus1 = 53 * a;
    val plus2 = 2809 * b;
    val plus3 = 148877 * c;
    val interm = plus1 + plus2;
    val mod1 = interm + plus3;
    val mod2 = 1000000007;
    mod1 % mod2
}

def main() {
    val n = ~readInt();
    val res = run(n, n);
    val _ = ~printInt(res);
    0
}

