
effect Abort {
  dcl done
}

def product(xs, abort_stub) {
    val cond = ~listIsEmpty(xs);
    if cond then
        0
    else
        val y = ~listHead(xs);
        val ys = ~listTail(xs);
            val cond = y == 0;
            if cond then
                raise abort_stub.done 0
            else
                val p = product(ys, abort_stub);
                y * p
}

def enumerate(i) {
    val cond = i < 0;
    if cond then
        ~listEnd()
    else
        val arg1 = i - 1;
        val arg2 = enumerate(arg1);
        ~listNode(i, arg2)
}

obj abort(env) {
    exc done(r) {
        r
    }
}

def body(env, abort_stub) {
    val arg1 = env[0];
    product(arg1, abort_stub)
}

def runProduct(xs) {
    handle {xs}
        body
    with abort: Abort
}

def loop(xs, i, a) {
    val cond = i == 0;
    if cond then
        a
    else
        val arg1 = i - 1;
        val arg2 = runProduct(xs);
        val arg3 = a + arg2;
        loop(xs, arg1, arg3)
}

def run(n) {
    val xs = enumerate(1000);
        loop(xs, n, 0)
}

def main() {
    val arg1 = ~readInt();
    val arg2 = run(arg1);
    val _ = ~printInt(arg2);
    0
}