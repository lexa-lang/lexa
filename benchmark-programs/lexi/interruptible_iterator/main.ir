effect Yield {
    dcl yield
}
effect Replace {
    dcl replace
}
effect Behead {
    dcl behead
}

def loop_body_1(env, replace_stub) {
    val it = env[0];
    val yield_stub = env[1];
    val behead_stub = env[2];
    val v = ~listHead(it);
    raise yield_stub.yield v behead_stub replace_stub
}

obj replace_loop(env) {
    def replace(x) {
        val it = env[0];
        ~listSetHead(it, x)
    }
}

def loop_body_2(env, behead_stub) {
    val it_tail = env[0];
    val yield_stub = env[1];
    loop(it_tail, yield_stub, behead_stub)
}

obj loop_behead(env) {
    def behead(_) {
        val it = env[0];
        val beheaded = env[2];
        beheaded[0] := 1
    }
}

def loop(it, yield_stub, behead_stub) {
    val _ = handle {it, yield_stub, behead_stub}
            loop_body_1
        with replace_loop: Replace;
    val it_tail = ~listTail(it);
    val beheaded = newref {0};
    val newtl = 
        if ~listIsEmpty(it_tail) then
            ~listEnd()
        else
            handle {it_tail, yield_stub, beheaded}
                loop_body_2
            with loop_behead: Behead;
    val tobehead = beheaded[0];
    val _ =
        if tobehead then
            val tailtail = ~listTail(newtl);
            ~listSetTail(it, tailtail)
        else
            0;
    it
            
}

def body_main_2(env, yield_stub) {
    val behead_stub = env[0];
    val l = env[1];
    loop(l, yield_stub, behead_stub)
}

obj yield_main(env) {
    def yield(x, behead_stub, replace_stub) {
        if x < 0 then
            raise behead_stub.behead 0
        else
            raise replace_stub.replace (x * 2)
    }
}

def body_main_1(env, behead_stub) {
    val l = env[0];
    handle {behead_stub, l}
        body_main_2
    with yield_main: Yield
}

obj behead_main(env) {
    def behead(_) {
        val beheaded = env[1];
        beheaded[0] := 1
    }
}

def listSum(l, acc) {
    if ~listIsEmpty(l) then
        acc
    else
        listSum(~listTail(l), acc + ~listHead(l))
}

def run(n) {
    val l = ~listRange(0 - n, n);
    val beheaded = newref {0};
    val newtl = 
        handle {l, beheaded}
            body_main_1
        with behead_main: Behead;
    val tobehead = beheaded[0];
    val res =
        if tobehead then
            ~listTail(newtl)
        else
            newtl;
    listSum(res)
}

def step(i, acc, n_jobs) {
    if i == 0 then
        acc
    else
        step(i - 1, acc + run(n_jobs), n_jobs)
}

def repeat(n_jobs) {
    step(1000, 0, n_jobs)
}

def main() {
    val arg1 = ~readInt();
    val arg2 = repeat(arg1);
    val _ = ~printInt(arg2);
    0
}