effect Yield {
    dcl yield
}
effect Replace {
    dcl replace
}
effect Behead {
    dcl behead
}

def loop_body_1(env, replace_stub) {
    val it = env[0];
    val yield_stub = env[1];
    val behead_stub = env[2];
    val v = ~listHead(it);
    raise yield_stub.yield v, behead_stub, replace_stub
}

obj replace_loop(env) {
    def replace(x) {
        val it = env[0];
        ~listSetHead(it, x)
    }
}

def loop_body_2(env, behead_stub) {
    val it_tail = env[0];
    val yield_stub = env[1];
    loop(it_tail, yield_stub, behead_stub)
}

obj loop_behead(env) {
    def behead(_) {
        val it = env[0];
        val beheaded = env[2];
        beheaded[0] := 1
    }
}

def loop(it, yield_stub, behead_stub) {
    val _ = handle <it, yield_stub, behead_stub>
            loop_body_1
        with replace_loop: Replace;
    val it_tail = ~listTail(it);
    val beheaded = newref <0>;
    val cond = ~listIsEmpty(it_tail);
    val newtl = 
        if cond then
            ~listEnd()
        else
            handle <it_tail, yield_stub, beheaded>
                loop_body_2
            with loop_behead: Behead;
    val tobehead = beheaded[0];
    val _ =
        if tobehead then
            val tailtail = ~listTail(newtl);
            ~listSetTail(it, tailtail)
        else
            0;
    it
            
}

def body_main_2(env, yield_stub) {
    val behead_stub = env[0];
    val l = env[1];
    loop(l, yield_stub, behead_stub)
}

obj yield_main(env) {
    def yield(x, behead_stub, replace_stub) {
        val cond = x < 0;
        if cond then
            raise behead_stub.behead 0
        else
            val x2 = x * 2;
            raise replace_stub.replace x2
    }
}

def body_main_1(env, behead_stub) {
    val l = env[0];
    handle <behead_stub, l>
        body_main_2
    with yield_main: Yield
}

obj behead_main(env) {
    def behead(_) {
        val beheaded = env[1];
        beheaded[0] := 1
    }
}

def listSum(l, acc) {
    val cond = ~listIsEmpty(l);
    if cond then
        acc
    else
        val head = ~listHead(l);
        val tail = ~listTail(l);
        val newacc = acc + head;
        listSum(tail, newacc)
}

def run(n) {
    val minusn = 0 - n;
    val l = ~listRange(minusn, n);
    val beheaded = newref <0>;
    val newtl = 
        handle <l, beheaded>
            body_main_1
        with behead_main: Behead;
    val tobehead = beheaded[0];
    val res =
        if tobehead then
            ~listTail(newtl)
        else
            newtl;
    listSum(res)
}

def step(i, acc, n_jobs) {
    val cond = i == 0;
    if cond then
        acc
    else
        val i_dec = i - 1;
        val res = run(n_jobs);
        val acc2 = acc + res;
        step(i_dec, acc2, n_jobs)
}

def repeat(n_jobs) {
    step(1000, 0, n_jobs)
}

def main() {
    val arg1 = ~readInt();
    val arg2 = repeat(arg1);
    val _ = ~printInt(arg2);
    0
}