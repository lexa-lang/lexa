
struct node[T] = { 
    iso payload : T;
    next : node;
}

struct circularList[T] = {
    iso head : node[T]?;
}

def getPayload(l: circularList[T]): T? {
    match l.head with
    | Some(node) => {
        if node.next == node {
            // node is the only node in the list
            l.head = None;
            Some(node.payload)
        } else {
            // copy the next node's payload to the current node
            // and remove the next node
            val payload = node.payload
            node.payload = node.next.payload;
            node.next = node.next.next;
            Some(payload)
        }
    }
    | None => {
        None
    }
}

effect Yield
| yield: () -> ()

type dataT
// threadT is a continuation, after it is resumed, it either finishes and return a unit
// or it yields and return a continuation
type threadT = μα.() ~> Either[α, ()]

def run(l: circularList[dataT]) {
    // buildThread returns a resumption that captures l
    def buildThread(): threadT {
        handle {
            while True {
                match getPayload(l) with
                | Some(payload) => {
                    // work on payload
                }
                | None => {
                    pass
                };
                raise Yield.yield();
            };
            Right(())
        } with Yield => {
            def yield(k) {
                Left(k)
            }
        }
    }

    // build a list of threads
    def buildThreadList(n): node[threadT] {
        val firstNode = { payload = buildThread(); };
        firstNode.next = firstNode;
        val lastNode = firstNode;
        for i in 1..n {
            val newNode = { payload = buildThread(); };
            newNode.next = firstNode;
            lastNode.next = newNode;
            lastNode = newNode;
        };
        firstNode
    }

    // nodePointer is a node in a circular list that doesn't change size
    val nodePointer: node[threadT] = buildThreadList(10);
    while True {
        val thread: threadT = nodePointer.payload.get_left();
        val newThread = resume thread();
        nodePointer.payload = newThread;
        nodePointer = nodePointer.next;
    }
}