struct node[T] = { 
    iso payload : T;
    iso next : node?;
}

struct sll[T] = {
    iso head : node[T]?;
}

struct producer[T] = {
    iso payload : T;
    lin next : () -> producer[T]?; // lin indicates that this field carries a permission, and invoking the function consumes the permission
}

effect Yield[T] {
    yield: (payload: T) -> () consumes payload;
}

def iterate(n: node[T]): <Yield> () consumes n {
    raise Yield.yield(n.payload);
    match n.next with
    | Some(next_node) => {
        iterate(next_node)
    }
    | None => {
        ()
    }
}

def produce(n: node[T]): producer[T]? consumes n {
    handle consumes n {
        iterate(n);
        None
    } with Yield => {
        def yield(payload, k) {
            Some(new producer(payload, k))
        }
    }
}

fun consume(p: producer[T]?) {
    match p {
    | Some(producer(payload, next)) => {
        work(payload); // work consumes payload
        consume(resume next())
    }
    | None => {
        ()
    }
    }
}

fun run(l: sll[T]) {
    match l.head {
    | Some(node) => {
        consume(produce(node))
    }
    | None => {
        ()
    }
    };
    l.head = None;
}