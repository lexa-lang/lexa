struct node[T] = { 
    iso payload : T;
    iso next : node?;
}

struct sll[T] = {
    iso head : node[T]?;
}

// next takes in the permission associated with payload
// I can't get a good syntax to indicate that, considering that we don't want to expose region to users
// My principel: inter-object permission relation should exists locally 
// so that they are hidden by type system and they are not exposed to users

// THE CORE OF THE PROBLEM: returning a resumption cross the boundary
// during which a permission-binding action should happen.
struct generator[T] = {
    iso payload : T;
    next : () -> generator[T]?;
}

effect Yield[T] {
    yield: (T) -> ();
}

def iterate(n: node[T]): Yield () {
    raise Yield.yield(n.payload);
    match n.next with
    | Some(next_node) => {
        iterate(next_node)
    }
    | None => {
        ()
    }
}

def generate(l: sll[T]): generator[T]? {
    match l.head with
    | Some(node) => {
        handle {
            iterate(node);
            None
        } with Yield => {
            def yield(payload, k) {
                Some(new generator(payload, k))
            }
        }
    }
    | None => {
        None
    }
}