effect Scheduler {
    dcl yield
    dcl fork
}

def spawn(job_closure, suspend_closure, runnext_closure) {
    let _ = handle <job_closure, suspend_closure, runnext_closure>
        body
    with scheduler: Scheduler in
    let runnext_func = runnext_closure[0] in
    let job_queue = runnext_closure[1] in
    runnext_func(job_queue)
}

obj scheduler(env) {
    hdl_1 yield(_, k) {
        let suspend_closure = env[1] in
        let suspend_func = suspend_closure[0] in
        let job_queue = suspend_closure[1] in
        let _ = suspend_func(job_queue, k) in
        let runnext_closure = env[2] in
        let runnext_func = runnext_closure[0] in
        let job_queue = runnext_closure[1] in
        runnext_func(job_queue)
    }

    hdl_1 fork(newjob_closure, k) {
        let suspend_closure = env[1] in
        let suspend_func = suspend_closure[0] in
        let suspend_env = suspend_closure[1] in
        let _ = suspend_func(suspend_env, k) in
        let arg1 = env[1] in
        let arg2 = env[2] in
        spawn(newjob_closure, arg1, arg2)
    }
}

def job(state, sch_stub) {
    let _ = raise sch_stub.yield 0 in
    let v1 = state[0] in
    let res1 = v1 + 1 in
    let _ = state[0] := res1 in
    let _ = raise sch_stub.yield 0 in
    let v3 = state[0] in
    let res2 = v3 + 1 in
    state[0] := res2
}

def loop(i, job_closure, sch_stub) {
    let cond = i == 0 in
    if cond then
        0
    else
        let _ = raise sch_stub.fork job_closure in
        let arg1 = i - 1 in
        loop(arg1, job_closure, sch_stub)
}

def entry(env, sch_stub) {
    let n = env[0] in
    let job_closure = env[1] in
    loop(n, job_closure, sch_stub)
}

def suspend(job_queue, k) {
    ~queueEnq(job_queue, k)
}

def runnext(job_queue) {
    let cond = ~queueIsEmpty(job_queue) in
    if cond then
        0
    else
        let k = ~queueDeq(job_queue) in
        resume_final k 0
}

def body(env, sch_stub) {
    let job_closure = env[0] in
    let job_func = job_closure[0] in
    let job_env = job_closure[1] in
    job_func(job_env, sch_stub)
}

def startScheduler(init_closure) {
    let job_queue = ~queueMake() in
    let suspend_closure = newref <suspend, job_queue> in
    let runnext_closure = newref <runnext, job_queue> in
    spawn(init_closure, suspend_closure, runnext_closure)
}

def run(n) {
    let state = newref <0> in
    let job_closure = newref <job, state> in
    let entry_env = newref <n, job_closure> in
    let entry_closure = newref <entry, entry_env> in
        let _ = startScheduler(entry_closure) in
        state[0]
}


def main() {
    let arg1 = ~readInt() in
    let arg2 = run(arg1) in
    let _ = ~printInt(arg2) in
    0
}