effect Process {
    dcl yield
    dcl fork
}

effect Tick {
    dcl tick
}

effect Exn {
    dcl throw
}

def queueDeqExn(q, exn_stub) {
    let cond = ~queueIsEmpty(q) in
    if cond then
        raise exn_stub.throw 0
    else
        ~queueDeq(q)
}

def job(env, sch_stub) {
    raise sch_stub.yield 0
}

def entry(env, sch_stub) {
    let n_jobs = env[0] in
    let job_closure = env[1] in
    let tick_stub = env[2] in
    jobs(n_jobs, job_closure, sch_stub, tick_stub)
}

def jobs(i, job_closure, sch_stub, tick_stub) {
    let cond = i == 0 in
    if cond then
        0
    else
        let _ = raise sch_stub.fork job_closure in
        let a = raise tick_stub.tick 0 in
        let i0 = i - 1 in
            jobs(i0, job_closure, sch_stub, tick_stub)
}

obj process(env) {
    hdl_1 yield(_, k) {
        let job_queue = env[1] in
        ~queueEnq(job_queue, k)
    }

    hdl_1 fork(newjob_closure, k) {
        let job_queue = env[1] in
        let _ = ~queueEnq(job_queue, k) in
        spawn(newjob_closure, job_queue)
    }
}

def body(env, sch_stub) {
    let job_closure = env[0] in
    let job_func = job_closure[0] in
    let job_env = job_closure[1] in
    job_func(job_env, sch_stub)
}

def body_driver(env, exn_stub) {
    let job_queue = env[0] in
    let k = queueDeqExn(job_queue, exn_stub) in
    let _ = resume_final k 0 in
    driver(job_queue)
}

obj exn(env) {
    exc throw(_) {
        0
    }
}

def driver(job_queue) {
    let _ = 
        handle <job_queue>
            body_driver
        with exn: Exn in
    0
}

def spawn(job_closure, job_queue) {
    handle <job_closure, job_queue>
        body
    with process: Process
}

def scheduler(init_closure) {
    let job_queue = ~queueMake () in
    let _ = spawn(init_closure, job_queue) in
    driver(job_queue)
}

obj tick(env) {
    def tick(_) {
        let c = env[1] in
        let v1 = c[0] in
        let v2 = v1 + 1 in
        let _ = c[0] := v2 in
        0
    }
}

def body_run(env, tick_stub) {
    let n_jobs = env[0] in
    let empty = newref <> in
    let job_closure = newref <job, empty> in
    let entry_env = newref <n_jobs, job_closure, tick_stub> in
    let entry_closure = newref <entry, entry_env> in
    scheduler(entry_closure)
}

def run(n_jobs) {
    let c = newref <0> in
    let _ = 
        handle <n_jobs, c>
            body_run
        with tick: Tick in
    let v = c[0] in
    v
}


def main() {
    let arg1 = ~readInt() in
    let arg2 = run(arg1) in
    let _ = ~printInt(arg2) in
    0
}