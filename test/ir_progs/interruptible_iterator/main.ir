effect Yield {
    dcl yield
}
effect Replace {
    dcl replace
}
effect Behead {
    dcl behead
}

def body_loop_1(env, replace_stub) {
    let it = env[0] in
    let yield_stub = env[1] in
    let behead_stub = env[2] in
    let val = ~listHead(it) in
    let bundle = newref <val, behead_stub, replace_stub> in
    raise yield_stub.yield bundle
}

obj replace_loop(env) {
    def replace(x) {
        let it = env[0] in
        ~listSetHead(it, x)
    }
}

def body_loop_2(env, behead_stub) {
    let it = env[0] in
    let yield_stub = env[1] in
    let it_tail = ~listTail(it) in
    loop(it_tail, yield_stub, behead_stub)
}

obj behead_loop(env) {
    def behead(_) {
        let it = env[0] in
        let it_tail = ~listTail(it) in
        let it_tail_tail = ~listTail(it_tail) in
        ~listSetTail(it, it_tail_tail)
    }
}

def loop(it, yield_stub, behead_stub) {
    let _ = 
        handle <it, yield_stub, behead_stub>
            body_loop_1
        with replace_loop: Replace in
    let it_tail = ~listTail(it) in
    let cond = ~listIsEmpty(it_tail) in
        if cond then
            0
        else
            handle <it, yield_stub>
                body_loop_2
            with behead_loop: Behead
}

def body_main_2(env, yield_stub) {
    let behead_stub = env[0] in
    let l = env[1] in
    loop(l, yield_stub, behead_stub)
}

obj yield_main(env) {
    def yield(bundle) {
        let x = bundle[0] in
        let behead_stub = bundle[1] in
        let replace_stub = bundle[2] in
        let cond = x < 0 in
        if cond then
            raise behead_stub.behead 0
        else
            let x2 = x * 2 in
            raise replace_stub.replace x2
    }
}

def body_main_1(env, behead_stub) {
    let lref = env[0] in
    let l = lref[0] in
    handle <behead_stub, l>
        body_main_2
    with yield_main: Yield
}

obj behead_main(env) {
    def behead(_) {
        let lref = env[0] in
        let l = lref[0] in
        let ltail = ~listTail(l) in
        let _ = lref[0] := ltail in
        0
    }
}

def run(n) {
    let minusn = 0 - n in
    let l = ~listRange(minusn, n) in
    let lref = newref <l> in
    let _ = 
        handle <lref>
            body_main_1
        with behead_main: Behead in
    let l1 = lref[0] in
    let _ = ~listPrint(l1) in
    0
}

def main() {
    let arg1 = ~readInt() in
    let arg2 = run(arg1) in
    let _ = ~printInt(arg2) in
    0
}