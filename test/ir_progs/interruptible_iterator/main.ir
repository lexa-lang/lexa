effect Yield {
    dcl yield
}
effect Replace {
    dcl replace
}
effect Behead {
    dcl behead
}

def loop_body_1(env, replace_stub) {
    let it = env[0] in
    let yield_stub = env[1] in
    let behead_stub = env[2] in
    let val = ~listHead(it) in
    raise yield_stub.yield val, behead_stub, replace_stub
}

obj replace_loop(env) {
    def replace(x) {
        let it = env[0] in
        ~listSetHead(it, x)
    }
}

def loop_body_2(env, behead_stub) {
    let it_tail = env[0] in
    let yield_stub = env[1] in
    loop(it_tail, yield_stub, behead_stub)
}

obj loop_behead(env) {
    def behead(_) {
        let it = env[0] in
        let beheaded = env[2] in
        beheaded[0] := 1
    }
}

def loop(it, yield_stub, behead_stub) {
    let _ = 
        handle <it, yield_stub, behead_stub>
            loop_body_1
        with replace_loop: Replace in
    let it_tail = ~listTail(it) in
    let beheaded = newref <0> in
    let cond = ~listIsEmpty(it_tail) in
    let newtl = 
        if cond then
            ~listEnd()
        else
            handle <it_tail, yield_stub, beheaded>
                loop_body_2
            with loop_behead: Behead
    in
    let tobehead = beheaded[0] in
    let _ =
        if tobehead then
            let tailtail = ~listTail(newtl) in
            ~listSetTail(it, tailtail)
        else
            0
    in it
            
}

def body_main_2(env, yield_stub) {
    let behead_stub = env[0] in
    let l = env[1] in
    loop(l, yield_stub, behead_stub)
}

obj yield_main(env) {
    def yield(x, behead_stub, replace_stub) {
        let cond = x < 0 in
        if cond then
            raise behead_stub.behead 0
        else
            let x2 = x * 2 in
            raise replace_stub.replace x2
    }
}

def body_main_1(env, behead_stub) {
    let l = env[0] in
    handle <behead_stub, l>
        body_main_2
    with yield_main: Yield
}

obj behead_main(env) {
    def behead(_) {
        let beheaded = env[1] in
        beheaded[0] := 1
    }
}

def listSum(l, acc) {
    let cond = ~listIsEmpty(l) in
    if cond then
        acc
    else
        let head = ~listHead(l) in
        let tail = ~listTail(l) in
        let newacc = acc + head in
        listSum(tail, newacc)
}

def run(n) {
    let minusn = 0 - n in
    let l = ~listRange(minusn, n) in
    let beheaded = newref <0> in
    let newtl = 
        handle <l, beheaded>
            body_main_1
        with behead_main: Behead in
    let tobehead = beheaded[0] in
    let res =
        if tobehead then
            ~listTail(newtl)
        else
            newtl
    in
    listSum(res)
}

def step(i, acc, n_jobs) {
    let cond = i == 0 in
    if cond then
        acc
    else
        let i_dec = i - 1 in
        let res = run(n_jobs) in
        let acc2 = acc + res in
        step(i_dec, acc2, n_jobs)
}

def repeat(n_jobs) {
    step(1000, 0, n_jobs)
}

def main() {
    let arg1 = ~readInt() in
    let arg2 = repeat(arg1) in
    let _ = ~printInt(arg2) in
    0
}