/// <reference types="node" resolution-mode="require"/>
import type { Duplex as NodeDuplex } from 'node:stream';
import { type Options, type QueueAddOptions } from 'p-queue';
export type TransformLike<T = any> = {
    push: (chunk: T) => void;
};
export type TransformMethod<T = any> = (this: TransformLike<T>, chunk: T) => PromiseLike<T | undefined> | T | undefined;
export type DuplexWithDebug = NodeDuplex & {
    enableDebug: () => NodeDuplex;
};
/**
 * Out of orderer queue result emitter.
 */
export declare class OutOfOrder<ChunkType> implements AsyncIterable<ChunkType> {
    #private;
    constructor(transform: TransformMethod<ChunkType>, pqueueOptions?: Options<any, QueueAddOptions>);
    [Symbol.asyncIterator](): AsyncIterator<ChunkType>;
    push(chunk: ChunkType): void;
    duplex(end?: (this: {
        push: (chunk: ChunkType) => void;
    }) => void | Promise<void>): DuplexWithDebug;
    /**
     * Queue chunk to be emitted.
     */
    protected pushResult(chunk: ChunkType): void;
    protected close(): Promise<void>;
    protected flush(): Promise<void>;
    private debug;
}
