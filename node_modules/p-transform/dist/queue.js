import { setTimeout } from 'node:timers/promises';
import { Readable as _Readable, Duplex as _Duplex } from 'readable-stream';
import PQueue from 'p-queue';
const Readable = _Readable;
const Duplex = _Duplex;
// eslint-disable-next-line @typescript-eslint/promise-function-async
const createPromise = () => {
    let resolve;
    let reject;
    const promise = new Promise((promiseResolve, promiseReject) => {
        resolve = promiseResolve;
        reject = promiseReject;
    });
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    return Object.assign(promise, { resolve, reject });
};
/**
 * Out of orderer queue result emitter.
 */
export class OutOfOrder {
    #queue;
    #closed = false;
    #nextPromise;
    #resolve;
    #results = [];
    #transform;
    #logPrefix;
    #debugEnabled = false;
    constructor(transform, pqueueOptions) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.#queue = new PQueue(pqueueOptions);
        this.#resolve = createPromise();
        this.#nextPromise = createPromise();
        this.#transform = transform;
        this.#logPrefix = Math.random().toString(36).slice(7);
    }
    async *[Symbol.asyncIterator]() {
        while (!this.#closed || this.#queue.size > 0 || this.#queue.pending > 0 || this.#results.length > 0) {
            // eslint-disable-next-line no-await-in-loop
            await this.#nextPromise;
            while (this.#results.length > 0) {
                yield this.#results.shift();
            }
            this.#nextPromise = createPromise();
        }
        this.debug('queue finished');
        this.#resolve.resolve();
    }
    push(chunk) {
        const transformContext = {
            push: chunk => {
                this.pushResult(chunk);
            },
        };
        this.#add(async () => this.#transform.call(transformContext, chunk));
    }
    /**
     * Queue the transform method.
     * Result is queued to be emitted.
     * Additional chunks can be added through `this.push` method.
     */
    #add(fn, options) {
        /* c8 ignore next 3 */
        if (this.#closed) {
            throw new Error('Queue is already closed');
        }
        this.#queue
            .add(async () => {
            const result = await fn();
            if (result !== undefined && result !== null) {
                this.pushResult(result);
            }
        }, options)
            .then(() => {
            this.#nextPromise.resolve();
        }, error => {
            this.#nextPromise.reject(error);
        });
    }
    duplex(end) {
        const transform = Duplex.from({
            readable: Readable.from(this),
            writable: Duplex.from(async (source) => {
                for await (const chunk of source) {
                    this.push(chunk);
                    // Wait next tick to continue.
                    // Improves responsiveness since it prioritize chunks to pass through the entire pipeline instead of buffering in a transform.
                    if (this.#queue.pending > 1) {
                        await setTimeout();
                    }
                }
                await this.flush();
                await end?.call?.({
                    push: chunk => {
                        this.pushResult(chunk);
                    },
                });
                await this.close();
            }),
        });
        return Object.assign(transform, {
            enableDebug: () => {
                this.#debugEnabled = true;
                this.debug('debug started');
                return transform;
            },
        });
    }
    /**
     * Queue chunk to be emitted.
     */
    pushResult(chunk) {
        this.debug('pushing chunk');
        /* c8 ignore next 3 */
        if (this.#closed) {
            throw new Error('Queue is already closed');
        }
        this.#results.push(chunk);
    }
    async close() {
        this.debug('closing');
        await this.flush();
        this.#closed = true;
        this.#nextPromise.resolve();
        await this.#resolve;
        this.debug('closed');
    }
    async flush() {
        await this.#queue.onIdle();
        this.#nextPromise.resolve();
    }
    debug(...args) {
        if (this.#debugEnabled) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            console.log(`#### ${this.#logPrefix} ####`, ...args);
        }
    }
}
