import PQueue from 'p-queue';
import type { Logger, InputOutputAdapter, PromptAnswers, PromptQuestions, ProgressCallback, ProgressOptions, QueuedAdapter as QueuedAdapterApi } from '@yeoman/types';
import { type TerminalAdapterOptions } from './adapter.js';
export type AdapterWithProgress = QueuedAdapterApi;
type Task<TaskResultType> = ((adapter: InputOutputAdapter) => PromiseLike<TaskResultType>) | ((adapter: InputOutputAdapter) => TaskResultType);
type QueuedAdapterOptions = TerminalAdapterOptions & {
    queue?: PQueue;
    delta?: number;
    adapter?: InputOutputAdapter;
};
export declare class QueuedAdapter implements QueuedAdapterApi {
    #private;
    actualAdapter: InputOutputAdapter;
    delta: number;
    log: Logger;
    /**
     * `TerminalAdapter` is the default implementation of `Adapter`, an abstraction
     * layer that defines the I/O interactions.
     *
     * It provides a CLI interaction
     *
     * @constructor
     * @param {terminalAdapter}          [import('./adapter.js').default]
     */
    constructor(options?: QueuedAdapterOptions);
    newAdapter(delta?: number): QueuedAdapter;
    close(): void;
    /**
     * Prompt a user for one or more questions and pass
     * the answer(s) to the provided callback.
     *
     * It shares its interface with `Base.prompt`
     *
     * (Defined inside the constructor to keep interfaces separated between
     * instances)
     *
     * @param {Object|Object[]} questions
     * @param {Object} [answers] Answers to be passed to inquirer
     * @return {Object} promise answers
     */
    prompt<A extends PromptAnswers = PromptAnswers>(questions: PromptQuestions<A>, initialAnswers?: Partial<A>): Promise<A>;
    onIdle(): Promise<void>;
    /**
     * Basic queue is recommended for blocking calls.
     * @param fn
     * @returns
     */
    queue<TaskResultType>(fn: Task<TaskResultType>): Promise<TaskResultType | void>;
    /**
     * Log has a highest priority and should be not blocking.
     * @param fn
     * @returns
     */
    queueLog<TaskResultType>(fn: Task<TaskResultType>): Promise<TaskResultType | void>;
    /**
     * Progress is blocking, but will be skipped if the queue is not empty.
     * @param callback
     * @param options
     * @returns
     */
    progress<ReturnType>(fn: ProgressCallback<ReturnType>, options?: ProgressOptions): Promise<void | ReturnType>;
}
export {};
