/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-redundant-type-constituents */
import events from 'node:events';
import { PassThrough } from 'node:stream';
import { createPromptModule } from 'inquirer';
import { createLogger } from '../log.js';
const defaultConfig = {};
export class DummyPrompt {
    answers;
    question;
    callback;
    throwOnMissingAnswer = defaultConfig.throwOnMissingAnswer ?? false;
    constructor(question, _rl, answers, options = {}) {
        const { mockedAnswers, callback, throwOnMissingAnswer } = options;
        this.answers = { ...answers, ...mockedAnswers };
        this.question = question;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        this.callback = callback ?? (answers => answers);
        this.throwOnMissingAnswer = throwOnMissingAnswer ?? false;
    }
    async run() {
        let answer = this.answers[this.question.name];
        let isSet;
        switch (this.question.type) {
            case 'list': {
                // List prompt accepts any answer value including null
                isSet = answer !== undefined;
                break;
            }
            case 'confirm': {
                // Ensure that we don't replace `false` with default `true`
                isSet = answer || answer === false;
                break;
            }
            default: {
                // Other prompts treat all falsy values to default
                isSet = Boolean(answer);
            }
        }
        if (!isSet) {
            if (answer === undefined && this.question.default === undefined) {
                const missingAnswerMessage = `yeoman-test: question ${this.question.name ?? ''} was asked but answer was not provided`;
                console.warn(missingAnswerMessage);
                if (this.throwOnMissingAnswer) {
                    throw new Error(missingAnswerMessage);
                }
            }
            answer = this.question.default;
            if (answer === undefined && this.question.type === 'confirm') {
                answer = true;
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.callback(answer, { question: this.question, answers: this.answers });
    }
}
export const defineConfig = (config) => Object.assign(defaultConfig, config);
export const getConfig = () => ({ ...defaultConfig });
/**
 * @experimental
 */
export class TestAdapter {
    promptModule;
    diff;
    log;
    registerDummyPrompt;
    spyFactory;
    constructor(options = {}) {
        const { 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        spyFactory = defaultConfig.spyFactory ?? (spyOptions => () => spyOptions.returns), log = defaultConfig.log ?? createLogger(), ...promptOptions } = options;
        this.spyFactory = spyFactory;
        this.promptModule = createPromptModule({
            input: new PassThrough(),
            output: new PassThrough(),
            // eslint-disable-next-line @typescript-eslint/naming-convention
            skipTTYChecks: true,
        });
        const actualRegisterPrompt = this.promptModule.registerPrompt.bind(this.promptModule);
        this.registerDummyPrompt = (promptModuleName, customPromptOptions) => actualRegisterPrompt(promptModuleName, class CustomDummyPrompt extends DummyPrompt {
            constructor(question, rl, answers) {
                super(question, rl, answers, customPromptOptions ?? promptOptions);
            }
        });
        this.promptModule.registerPrompt = (name) => this.registerDummyPrompt(name);
        for (const promptName of Object.keys(this.promptModule.prompts)) {
            this.promptModule.registerPrompt(promptName, undefined);
        }
        this.diff = this.spyFactory({});
        this.log = this.spyFactory({});
        Object.assign(this.log, events.EventEmitter.prototype);
        const descriptors = Object.getOwnPropertyDescriptors(log);
        // Make sure all log methods are defined
        const logMethods = Object.entries(descriptors)
            .filter(([method, desc]) => typeof desc.value === 'function' && !Object.getOwnPropertyDescriptor(this.log, method))
            .map(([method]) => method);
        for (const methodName of logMethods) {
            this.log[methodName] = this.spyFactory({ returns: this.log });
        }
    }
    async queue(fn) {
        return fn(this);
    }
    async progress(fn, _options) {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        return fn({ step() { } });
    }
    close() {
        this.promptModule.restoreDefaultPrompts();
    }
    async prompt(questions, initialAnswers) {
        return this.promptModule(questions, initialAnswers);
    }
}
//# sourceMappingURL=test-adapter.js.map