/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { type PipelineSource, type PipelineTransform, type PipelineTransformSource, Transform, type PipelineOptions } from 'node:stream';
import type { pipeline as pipelineType } from 'node:stream/promises';
import { type MinimatchOptions } from 'minimatch';
declare const pipeline: typeof pipelineType;
export { pipeline };
export type File = {
    path: string;
    contents: any;
};
type TransformFile<F extends File = File> = (this: Transform, file: F) => Promise<F | undefined> | F | undefined;
type PassthroughFile<F extends File = File> = (file: F) => Promise<void> | void;
type FilterFile<F extends File = File> = (file: F) => Promise<boolean> | boolean;
export type FilePipelineTransform<F extends File = File> = PipelineTransform<PipelineTransformSource<F>, F>;
export declare const filePipeline: <F extends File = File>(source: PipelineSource<F>, transforms: FilePipelineTransform<F>[], options?: PipelineOptions) => Promise<void>;
/**
 * The returned file from transform function is passed through if any.
 */
export declare function transform<F extends File = File>(fn: TransformFile<F>): Transform;
type TransformMinimatchOptions = {
    /** Minimatch options */
    patternOptions?: MinimatchOptions;
};
export type PassthroughOptions<F extends File = File> = {
    filter?: FilterFile<F>;
    pattern?: string;
} & TransformMinimatchOptions;
/**
 * Files will always be passed through.
 */
export declare function passthrough<F extends File = File>(fn?: PassthroughFile<F>, options?: PassthroughOptions<F>): Transform;
export type TransformFileField<K extends keyof F, F extends File = File> = (value: F[K], f: F) => F[K] | Promise<F[K]>;
export declare function transformFileField<K extends keyof F, F extends File = File>(field: K, fieldValue: F[K] | TransformFileField<K, F>, options?: PassthroughOptions<F>): Transform;
export declare function transformContents<F extends File = File>(fn: (contents: F['contents']) => F['contents'] | Promise<F['contents']>, options?: PassthroughOptions<F>): Transform;
/**
 * Filter file.
 * Files that doesn't match the filter condition are removed.
 */
export declare function filter<F extends File = File>(filter: FilterFile<F>): Transform;
/**
 * Conditional filter on pattern.
 * Files that doesn't match the pattern are removed.
 */
export declare function filterPattern(pattern: string, options?: TransformMinimatchOptions): Transform;
