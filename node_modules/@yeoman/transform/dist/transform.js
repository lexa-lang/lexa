import { Transform, } from 'node:stream';
import { Stream } from 'readable-stream';
import { Minimatch } from 'minimatch';
// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, prefer-destructuring
const pipeline = Stream.promises.pipeline;
export { pipeline };
export const filePipeline = async (source, transforms, options) => pipeline(source, ...transforms, ...(options ? [options] : []));
/**
 * The returned file from transform function is passed through if any.
 */
export function transform(fn) {
    return new Transform({
        objectMode: true,
        async transform(chunk, _encoding, callback) {
            try {
                callback(undefined, await fn.call(this, chunk));
            }
            catch (error) {
                callback(error);
            }
        },
    });
}
/**
 * Files will always be passed through.
 */
export function passthrough(fn, options = {}) {
    if (!fn) {
        return transform(f => f);
    }
    const { filter, pattern, patternOptions } = options;
    let patternFilter = () => true;
    if (pattern) {
        const minimatch = new Minimatch(pattern, patternOptions);
        patternFilter = (file) => minimatch.match(file.path);
    }
    return transform(async (file) => {
        if (filter && !filter(file)) {
            return file;
        }
        if (await patternFilter(file)) {
            await fn(file);
        }
        return file;
    });
}
export function transformFileField(field, fieldValue, options) {
    if (typeof fieldValue === 'function') {
        return passthrough(async (file) => {
            file[field] = await fieldValue(file[field], file);
        }, options);
    }
    return passthrough(async (file) => {
        file[field] = fieldValue;
    }, options);
}
export function transformContents(fn, options) {
    return transformFileField('contents', fn, options);
}
/**
 * Filter file.
 * Files that doesn't match the filter condition are removed.
 */
export function filter(filter) {
    return transform(async (file) => ((await filter(file)) ? file : undefined));
}
/**
 * Conditional filter on pattern.
 * Files that doesn't match the pattern are removed.
 */
export function filterPattern(pattern, options = {}) {
    const minimatch = new Minimatch(pattern, options.patternOptions);
    return filter(file => minimatch.match(file.path));
}
//# sourceMappingURL=transform.js.map