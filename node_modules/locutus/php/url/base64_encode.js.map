{"version":3,"sources":["../../../src/php/url/base64_encode.js"],"names":["module","exports","base64_encode","stringToEncode","encodeUTF8string","str","encodeURIComponent","replace","toSolidBytes","match","p1","String","fromCharCode","window","btoa","Buffer","toString","b64","o1","o2","o3","h1","h2","h3","h4","bits","i","ac","enc","tmpArr","charCodeAt","charAt","length","join","r","slice"],"mappings":";;AAAAA,OAAOC,OAAP,GAAiB,SAASC,aAAT,CAAuBC,cAAvB,EAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMC,mBAAmB,SAAnBA,gBAAmB,CAAUC,GAAV,EAAe;AACtC;AACA;AACA;AACA,WAAOC,mBAAmBD,GAAnB,EAAwBE,OAAxB,CAAgC,iBAAhC,EAAmD,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,EAA7B,EAAiC;AACzF,aAAOC,OAAOC,YAAP,CAAoB,OAAOF,EAA3B,CAAP;AACD,KAFM,CAAP;AAGD,GAPD;;AASA,MAAI,OAAOG,MAAP,KAAkB,WAAtB,EAAmC;AACjC,QAAI,OAAOA,OAAOC,IAAd,KAAuB,WAA3B,EAAwC;AACtC,aAAOD,OAAOC,IAAP,CAAYV,iBAAiBD,cAAjB,CAAZ,CAAP;AACD;AACF,GAJD,MAIO;AACL,WAAO,IAAIY,MAAJ,CAAWZ,cAAX,EAA2Ba,QAA3B,CAAoC,QAApC,CAAP;AACD;;AAED,MAAMC,MAAM,mEAAZ;AACA,MAAIC,WAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,aAAJ;AACA,MAAIC,IAAI,CAAR;AACA,MAAIC,KAAK,CAAT;AACA,MAAIC,MAAM,EAAV;AACA,MAAMC,SAAS,EAAf;;AAEA,MAAI,CAAC1B,cAAL,EAAqB;AACnB,WAAOA,cAAP;AACD;;AAEDA,mBAAiBC,iBAAiBD,cAAjB,CAAjB;;AAEA,KAAG;AACD;AACAe,SAAKf,eAAe2B,UAAf,CAA0BJ,GAA1B,CAAL;AACAP,SAAKhB,eAAe2B,UAAf,CAA0BJ,GAA1B,CAAL;AACAN,SAAKjB,eAAe2B,UAAf,CAA0BJ,GAA1B,CAAL;;AAEAD,WAAQP,MAAM,EAAP,GAAcC,MAAM,CAApB,GAAyBC,EAAhC;;AAEAC,SAAMI,QAAQ,EAAT,GAAe,IAApB;AACAH,SAAMG,QAAQ,EAAT,GAAe,IAApB;AACAF,SAAME,QAAQ,CAAT,GAAc,IAAnB;AACAD,SAAKC,OAAO,IAAZ;;AAEA;AACAI,WAAOF,IAAP,IAAeV,IAAIc,MAAJ,CAAWV,EAAX,IAAiBJ,IAAIc,MAAJ,CAAWT,EAAX,CAAjB,GAAkCL,IAAIc,MAAJ,CAAWR,EAAX,CAAlC,GAAmDN,IAAIc,MAAJ,CAAWP,EAAX,CAAlE;AACD,GAfD,QAeSE,IAAIvB,eAAe6B,MAf5B;;AAiBAJ,QAAMC,OAAOI,IAAP,CAAY,EAAZ,CAAN;;AAEA,MAAMC,IAAI/B,eAAe6B,MAAf,GAAwB,CAAlC;;AAEA,SAAO,CAACE,IAAIN,IAAIO,KAAJ,CAAU,CAAV,EAAaD,IAAI,CAAjB,CAAJ,GAA0BN,GAA3B,IAAkC,MAAMO,KAAN,CAAYD,KAAK,CAAjB,CAAzC;AACD,CA/ED","file":"base64_encode.js","sourcesContent":["module.exports = function base64_encode(stringToEncode) {\n  //  discuss at: https://locutus.io/php/base64_encode/\n  // original by: Tyler Akins (https://rumkin.com)\n  // improved by: Bayron Guevara\n  // improved by: Thunder.m\n  // improved by: Kevin van Zonneveld (https://kvz.io)\n  // improved by: Kevin van Zonneveld (https://kvz.io)\n  // improved by: Rafał Kukawski (https://blog.kukawski.pl)\n  // bugfixed by: Pellentesque Malesuada\n  // improved by: Indigo744\n  //   example 1: base64_encode('Kevin van Zonneveld')\n  //   returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n  //   example 2: base64_encode('a')\n  //   returns 2: 'YQ=='\n  //   example 3: base64_encode('✓ à la mode')\n  //   returns 3: '4pyTIMOgIGxhIG1vZGU='\n\n  // encodeUTF8string()\n  // Internal function to encode properly UTF8 string\n  // Adapted from Solution #1 at https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\n  const encodeUTF8string = function (str) {\n    // first we use encodeURIComponent to get percent-encoded UTF-8,\n    // then we convert the percent encodings into raw bytes which\n    // can be fed into the base64 encoding algorithm.\n    return encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function toSolidBytes(match, p1) {\n      return String.fromCharCode('0x' + p1)\n    })\n  }\n\n  if (typeof window !== 'undefined') {\n    if (typeof window.btoa !== 'undefined') {\n      return window.btoa(encodeUTF8string(stringToEncode))\n    }\n  } else {\n    return new Buffer(stringToEncode).toString('base64')\n  }\n\n  const b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n  let o1\n  let o2\n  let o3\n  let h1\n  let h2\n  let h3\n  let h4\n  let bits\n  let i = 0\n  let ac = 0\n  let enc = ''\n  const tmpArr = []\n\n  if (!stringToEncode) {\n    return stringToEncode\n  }\n\n  stringToEncode = encodeUTF8string(stringToEncode)\n\n  do {\n    // pack three octets into four hexets\n    o1 = stringToEncode.charCodeAt(i++)\n    o2 = stringToEncode.charCodeAt(i++)\n    o3 = stringToEncode.charCodeAt(i++)\n\n    bits = (o1 << 16) | (o2 << 8) | o3\n\n    h1 = (bits >> 18) & 0x3f\n    h2 = (bits >> 12) & 0x3f\n    h3 = (bits >> 6) & 0x3f\n    h4 = bits & 0x3f\n\n    // use hexets to index into b64, and append result to encoded string\n    tmpArr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4)\n  } while (i < stringToEncode.length)\n\n  enc = tmpArr.join('')\n\n  const r = stringToEncode.length % 3\n\n  return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3)\n}\n"]}