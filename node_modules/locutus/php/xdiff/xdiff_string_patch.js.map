{"version":3,"sources":["../../../src/php/xdiff/xdiff_string_patch.js"],"names":["module","exports","xdiff_string_patch","originalStr","patch","flags","errorObj","_getNativeFlags","regex","global","ignoreCase","multiline","extended","sticky","join","_cbSplit","string","sep","RegExp","String","prototype","split","apply","arguments","str","output","lastLastIndex","match","lastLength","limit","Infinity","x","_xregexp","s","source","captureNames","slice","exec","lastIndex","push","index","length","Array","test","i","ll","ranges","lastLinePos","firstChar","rangeExp","lineBreaks","lines","replace","origLines","newStrArr","linePos","errors","optTemp","OPTS","XDIFF_PATCH_NORMAL","XDIFF_PATCH_REVERSE","XDIFF_PATCH_IGNORESPACE","concat","charAt","Error","value"],"mappings":"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","file":"xdiff_string_patch.js","sourcesContent":["module.exports = function xdiff_string_patch(originalStr, patch, flags, errorObj) {\n  //  discuss at: https://locutus.io/php/xdiff_string_patch/\n  // original by: Brett Zamir (https://brett-zamir.me)\n  // improved by: Steven Levithan (stevenlevithan.com)\n  //      note 1: The XDIFF_PATCH_IGNORESPACE flag and the error argument are not\n  //      note 1: currently supported.\n  //      note 2: This has not been tested exhaustively yet.\n  //      note 3: The errorObj parameter (optional) if used must be passed in as a\n  //      note 3: object. The errors will then be written by reference into it's `value` property\n  //   example 1: xdiff_string_patch('', '@@ -0,0 +1,1 @@\\n+Hello world!')\n  //   returns 1: 'Hello world!'\n\n  // First two functions were adapted from Steven Levithan, also under an MIT license\n  // Adapted from XRegExp 1.5.0\n  // (c) 2007-2010 Steven Levithan\n  // MIT License\n  // <https://xregexp.com>\n\n  const _getNativeFlags = function (regex) {\n    // Proposed for ES4; included in AS3\n    return [\n      regex.global ? 'g' : '',\n      regex.ignoreCase ? 'i' : '',\n      regex.multiline ? 'm' : '',\n      regex.extended ? 'x' : '',\n      regex.sticky ? 'y' : '',\n    ].join('')\n  }\n\n  const _cbSplit = function (string, sep) {\n    // If separator `s` is not a regex, use the native `split`\n    if (!(sep instanceof RegExp)) {\n      // Had problems to get it to work here using prototype test\n      return String.prototype.split.apply(string, arguments)\n    }\n    const str = String(string)\n    const output = []\n    let lastLastIndex = 0\n    let match\n    let lastLength\n    const limit = Infinity\n    const x = sep._xregexp\n    // This is required if not `s.global`, and it avoids needing to set `s.lastIndex` to zero\n    // and restore it to its original value when we're done using the regex\n    // Brett paring down\n    const s = new RegExp(sep.source, _getNativeFlags(sep) + 'g')\n    if (x) {\n      s._xregexp = {\n        source: x.source,\n        captureNames: x.captureNames ? x.captureNames.slice(0) : null,\n      }\n    }\n\n    while ((match = s.exec(str))) {\n      // Run the altered `exec` (required for `lastIndex` fix, etc.)\n      if (s.lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index))\n\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1))\n        }\n\n        lastLength = match[0].length\n        lastLastIndex = s.lastIndex\n\n        if (output.length >= limit) {\n          break\n        }\n      }\n\n      if (s.lastIndex === match.index) {\n        s.lastIndex++\n      }\n    }\n\n    if (lastLastIndex === str.length) {\n      if (!s.test('') || lastLength) {\n        output.push('')\n      }\n    } else {\n      output.push(str.slice(lastLastIndex))\n    }\n\n    return output.length > limit ? output.slice(0, limit) : output\n  }\n\n  let i = 0\n  let ll = 0\n  let ranges = []\n  let lastLinePos = 0\n  let firstChar = ''\n  const rangeExp = /^@@\\s+-(\\d+),(\\d+)\\s+\\+(\\d+),(\\d+)\\s+@@$/\n  const lineBreaks = /\\r?\\n/\n  const lines = _cbSplit(patch.replace(/(\\r?\\n)+$/, ''), lineBreaks)\n  const origLines = _cbSplit(originalStr, lineBreaks)\n  const newStrArr = []\n  let linePos = 0\n  const errors = ''\n  let optTemp = 0 // Both string & integer (constant) input is allowed\n  const OPTS = {\n    // Unsure of actual PHP values, so better to rely on string\n    XDIFF_PATCH_NORMAL: 1,\n    XDIFF_PATCH_REVERSE: 2,\n    XDIFF_PATCH_IGNORESPACE: 4,\n  }\n\n  // Input defaulting & sanitation\n  if (typeof originalStr !== 'string' || !patch) {\n    return false\n  }\n  if (!flags) {\n    flags = 'XDIFF_PATCH_NORMAL'\n  }\n\n  if (typeof flags !== 'number') {\n    // Allow for a single string or an array of string flags\n    flags = [].concat(flags)\n    for (i = 0; i < flags.length; i++) {\n      // Resolve string input to bitwise e.g. 'XDIFF_PATCH_NORMAL' becomes 1\n      if (OPTS[flags[i]]) {\n        optTemp = optTemp | OPTS[flags[i]]\n      }\n    }\n    flags = optTemp\n  }\n\n  if (flags & OPTS.XDIFF_PATCH_NORMAL) {\n    for (i = 0, ll = lines.length; i < ll; i++) {\n      ranges = lines[i].match(rangeExp)\n      if (ranges) {\n        lastLinePos = linePos\n        linePos = ranges[1] - 1\n        while (lastLinePos < linePos) {\n          newStrArr[newStrArr.length] = origLines[lastLinePos++]\n        }\n        while (lines[++i] && rangeExp.exec(lines[i]) === null) {\n          firstChar = lines[i].charAt(0)\n          switch (firstChar) {\n            case '-':\n              // Skip including that line\n              ++linePos\n              break\n            case '+':\n              newStrArr[newStrArr.length] = lines[i].slice(1)\n              break\n            case ' ':\n              newStrArr[newStrArr.length] = origLines[linePos++]\n              break\n            default:\n              // Reconcile with returning errrors arg?\n              throw new Error('Unrecognized initial character in unidiff line')\n          }\n        }\n        if (lines[i]) {\n          i--\n        }\n      }\n    }\n    while (linePos > 0 && linePos < origLines.length) {\n      newStrArr[newStrArr.length] = origLines[linePos++]\n    }\n  } else if (flags & OPTS.XDIFF_PATCH_REVERSE) {\n    // Only differs from above by a few lines\n    for (i = 0, ll = lines.length; i < ll; i++) {\n      ranges = lines[i].match(rangeExp)\n      if (ranges) {\n        lastLinePos = linePos\n        linePos = ranges[3] - 1\n        while (lastLinePos < linePos) {\n          newStrArr[newStrArr.length] = origLines[lastLinePos++]\n        }\n        while (lines[++i] && rangeExp.exec(lines[i]) === null) {\n          firstChar = lines[i].charAt(0)\n          switch (firstChar) {\n            case '-':\n              newStrArr[newStrArr.length] = lines[i].slice(1)\n              break\n            case '+':\n              // Skip including that line\n              ++linePos\n              break\n            case ' ':\n              newStrArr[newStrArr.length] = origLines[linePos++]\n              break\n            default:\n              // Reconcile with returning errrors arg?\n              throw new Error('Unrecognized initial character in unidiff line')\n          }\n        }\n        if (lines[i]) {\n          i--\n        }\n      }\n    }\n    while (linePos > 0 && linePos < origLines.length) {\n      newStrArr[newStrArr.length] = origLines[linePos++]\n    }\n  }\n\n  if (errorObj) {\n    errorObj.value = errors\n  }\n\n  return newStrArr.join('\\n')\n}\n"]}