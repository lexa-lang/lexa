{"version":3,"sources":["../../../src/php/xdiff/xdiff_string_diff.js"],"names":["module","exports","xdiff_string_diff","oldData","newData","contextLines","minimal","i","j","k","oriHunkStart","newHunkStart","oriHunkEnd","newHunkEnd","oriHunkLineNo","newHunkLineNo","oriHunkSize","newHunkSize","MAX_CONTEXT_LINES","Number","POSITIVE_INFINITY","MIN_CONTEXT_LINES","DEFAULT_CONTEXT_LINES","HEADER_PREFIX","HEADER_SUFFIX","ORIGINAL_INDICATOR","NEW_INDICATOR","RANGE_SEPARATOR","CONTEXT_INDICATOR","DELETION_INDICATOR","ADDITION_INDICATOR","oriLines","newLines","NEW_LINE","_trim","text","Error","replace","_verifyType","type","args","arguments","argsLen","length","basicTypes","basicType","typeOfType","_hasValue","array","value","Array","_areTypeOf","_getInitializedArray","arraySize","initValue","push","_splitIntoLines","split","_isEmptyArray","obj","_findLongestCommonSequence","seq1","seq2","seq1IsInLcs","seq2IsInLcs","lcsLens","xs","ys","prev","curr","slice","Math","max","_findLcs","xidx","xIsIn","xb","xe","llB","llE","pivot","yb","ye","nx","ny","floor","reverse","concat","oriLen","newLen","oriIsInLcs","newIsInLcs","lcsLen","unidiff","join","leadingContext","trailingContext","actualLeadingContext","actualTrailingContext","regularizeLeadingContext","context","contextStartPos","regularizeTrailingContext","min","charAt"],"mappings":"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","file":"xdiff_string_diff.js","sourcesContent":["module.exports = function xdiff_string_diff(oldData, newData, contextLines, minimal) {\n  //  discuss at: https://locutus.io/php/xdiff_string_diff\n  // original by: Brett Zamir (https://brett-zamir.me)\n  //    based on: Imgen Tata (https://www.myipdf.com/)\n  // bugfixed by: Imgen Tata (https://www.myipdf.com/)\n  // improved by: Brett Zamir (https://brett-zamir.me)\n  //      note 1: The minimal argument is not currently supported\n  //   example 1: xdiff_string_diff('', 'Hello world!')\n  //   returns 1: '@@ -0,0 +1,1 @@\\n+Hello world!'\n\n  // (This code was done by Imgen Tata; I have only reformatted for use in Locutus)\n\n  // See https://en.wikipedia.org/wiki/Diff#Unified_format\n  let i = 0\n  let j = 0\n  let k = 0\n  let oriHunkStart\n  let newHunkStart\n  let oriHunkEnd\n  let newHunkEnd\n  let oriHunkLineNo\n  let newHunkLineNo\n  let oriHunkSize\n  let newHunkSize\n  const MAX_CONTEXT_LINES = Number.POSITIVE_INFINITY // Potential configuration\n  const MIN_CONTEXT_LINES = 0\n  const DEFAULT_CONTEXT_LINES = 3\n  const HEADER_PREFIX = '@@ ' //\n  const HEADER_SUFFIX = ' @@'\n  const ORIGINAL_INDICATOR = '-'\n  const NEW_INDICATOR = '+'\n  const RANGE_SEPARATOR = ','\n  const CONTEXT_INDICATOR = ' '\n  const DELETION_INDICATOR = '-'\n  const ADDITION_INDICATOR = '+'\n  let oriLines\n  let newLines\n  const NEW_LINE = '\\n'\n\n  const _trim = function (text) {\n    if (typeof text !== 'string') {\n      throw new Error('String parameter required')\n    }\n\n    return text.replace(/(^\\s*)|(\\s*$)/g, '')\n  }\n\n  const _verifyType = function (type) {\n    const args = arguments\n    const argsLen = arguments.length\n    const basicTypes = ['number', 'boolean', 'string', 'function', 'object', 'undefined']\n    let basicType\n    let i\n    let j\n    const typeOfType = typeof type\n    if (typeOfType !== 'string' && typeOfType !== 'function') {\n      throw new Error('Bad type parameter')\n    }\n\n    if (argsLen < 2) {\n      throw new Error('Too few arguments')\n    }\n\n    if (typeOfType === 'string') {\n      type = _trim(type)\n\n      if (type === '') {\n        throw new Error('Bad type parameter')\n      }\n\n      for (j = 0; j < basicTypes.length; j++) {\n        basicType = basicTypes[j]\n\n        if (basicType === type) {\n          for (i = 1; i < argsLen; i++) {\n            if (typeof args[i] !== type) {\n              throw new Error('Bad type')\n            }\n          }\n\n          return\n        }\n      }\n\n      throw new Error('Bad type parameter')\n    }\n\n    // Not basic type. we need to use instanceof operator\n    for (i = 1; i < argsLen; i++) {\n      if (!(args[i] instanceof type)) {\n        throw new Error('Bad type')\n      }\n    }\n  }\n\n  const _hasValue = function (array, value) {\n    let i\n    _verifyType(Array, array)\n\n    for (i = 0; i < array.length; i++) {\n      if (array[i] === value) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  const _areTypeOf = function (type) {\n    const args = arguments\n    const argsLen = arguments.length\n    const basicTypes = ['number', 'boolean', 'string', 'function', 'object', 'undefined']\n    let basicType\n    let i\n    let j\n    const typeOfType = typeof type\n\n    if (typeOfType !== 'string' && typeOfType !== 'function') {\n      throw new Error('Bad type parameter')\n    }\n\n    if (argsLen < 2) {\n      throw new Error('Too few arguments')\n    }\n\n    if (typeOfType === 'string') {\n      type = _trim(type)\n\n      if (type === '') {\n        return false\n      }\n\n      for (j = 0; j < basicTypes.length; j++) {\n        basicType = basicTypes[j]\n\n        if (basicType === type) {\n          for (i = 1; i < argsLen; i++) {\n            if (typeof args[i] !== type) {\n              return false\n            }\n          }\n\n          return true\n        }\n      }\n\n      throw new Error('Bad type parameter')\n    }\n\n    // Not basic type. we need to use instanceof operator\n    for (i = 1; i < argsLen; i++) {\n      if (!(args[i] instanceof type)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  const _getInitializedArray = function (arraySize, initValue) {\n    const array = []\n    let i\n    _verifyType('number', arraySize)\n\n    for (i = 0; i < arraySize; i++) {\n      array.push(initValue)\n    }\n\n    return array\n  }\n\n  const _splitIntoLines = function (text) {\n    _verifyType('string', text)\n\n    if (text === '') {\n      return []\n    }\n    return text.split('\\n')\n  }\n\n  const _isEmptyArray = function (obj) {\n    return _areTypeOf(Array, obj) && obj.length === 0\n  }\n\n  /**\n   * Finds longest common sequence between two sequences\n   * @see {@link https://wordaligned.org/articles/longest-common-subsequence}\n   */\n  const _findLongestCommonSequence = function (seq1, seq2, seq1IsInLcs, seq2IsInLcs) {\n    if (!_areTypeOf(Array, seq1, seq2)) {\n      throw new Error('Array parameters are required')\n    }\n\n    // Deal with edge case\n    if (_isEmptyArray(seq1) || _isEmptyArray(seq2)) {\n      return []\n    }\n\n    // Function to calculate lcs lengths\n    const lcsLens = function (xs, ys) {\n      let i\n      let j\n      let prev\n      const curr = _getInitializedArray(ys.length + 1, 0)\n\n      for (i = 0; i < xs.length; i++) {\n        prev = curr.slice(0)\n        for (j = 0; j < ys.length; j++) {\n          if (xs[i] === ys[j]) {\n            curr[j + 1] = prev[j] + 1\n          } else {\n            curr[j + 1] = Math.max(curr[j], prev[j + 1])\n          }\n        }\n      }\n\n      return curr\n    }\n\n    // Function to find lcs and fill in the array to indicate the optimal longest common sequence\n    const _findLcs = function (xs, xidx, xIsIn, ys) {\n      let i\n      let xb\n      let xe\n      let llB\n      let llE\n      let pivot\n      let max\n      let yb\n      let ye\n      const nx = xs.length\n      const ny = ys.length\n\n      if (nx === 0) {\n        return []\n      }\n      if (nx === 1) {\n        if (_hasValue(ys, xs[0])) {\n          xIsIn[xidx] = true\n          return [xs[0]]\n        }\n        return []\n      }\n      i = Math.floor(nx / 2)\n      xb = xs.slice(0, i)\n      xe = xs.slice(i)\n      llB = lcsLens(xb, ys)\n      llE = lcsLens(xe.slice(0).reverse(), ys.slice(0).reverse())\n\n      pivot = 0\n      max = 0\n      for (j = 0; j <= ny; j++) {\n        if (llB[j] + llE[ny - j] > max) {\n          pivot = j\n          max = llB[j] + llE[ny - j]\n        }\n      }\n      yb = ys.slice(0, pivot)\n      ye = ys.slice(pivot)\n      return _findLcs(xb, xidx, xIsIn, yb).concat(_findLcs(xe, xidx + i, xIsIn, ye))\n    }\n\n    // Fill in seq1IsInLcs to find the optimal longest common subsequence of first sequence\n    _findLcs(seq1, 0, seq1IsInLcs, seq2)\n    // Fill in seq2IsInLcs to find the optimal longest common subsequence\n    // of second sequence and return the result\n    return _findLcs(seq2, 0, seq2IsInLcs, seq1)\n  }\n\n  // First, check the parameters\n  if (_areTypeOf('string', oldData, newData) === false) {\n    return false\n  }\n\n  if (oldData === newData) {\n    return ''\n  }\n\n  if (typeof contextLines !== 'number' || contextLines > MAX_CONTEXT_LINES || contextLines < MIN_CONTEXT_LINES) {\n    contextLines = DEFAULT_CONTEXT_LINES\n  }\n\n  oriLines = _splitIntoLines(oldData)\n  newLines = _splitIntoLines(newData)\n  const oriLen = oriLines.length\n  const newLen = newLines.length\n  const oriIsInLcs = _getInitializedArray(oriLen, false)\n  const newIsInLcs = _getInitializedArray(newLen, false)\n  const lcsLen = _findLongestCommonSequence(oriLines, newLines, oriIsInLcs, newIsInLcs).length\n  let unidiff = ''\n\n  if (lcsLen === 0) {\n    // No common sequence\n    unidiff = [\n      HEADER_PREFIX,\n      ORIGINAL_INDICATOR,\n      oriLen > 0 ? '1' : '0',\n      RANGE_SEPARATOR,\n      oriLen,\n      ' ',\n      NEW_INDICATOR,\n      newLen > 0 ? '1' : '0',\n      RANGE_SEPARATOR,\n      newLen,\n      HEADER_SUFFIX,\n    ].join('')\n\n    for (i = 0; i < oriLen; i++) {\n      unidiff += NEW_LINE + DELETION_INDICATOR + oriLines[i]\n    }\n\n    for (j = 0; j < newLen; j++) {\n      unidiff += NEW_LINE + ADDITION_INDICATOR + newLines[j]\n    }\n\n    return unidiff\n  }\n\n  let leadingContext = []\n  let trailingContext = []\n  let actualLeadingContext = []\n  let actualTrailingContext = []\n\n  // Regularize leading context by the contextLines parameter\n  const regularizeLeadingContext = function (context) {\n    if (context.length === 0 || contextLines === 0) {\n      return []\n    }\n\n    const contextStartPos = Math.max(context.length - contextLines, 0)\n\n    return context.slice(contextStartPos)\n  }\n\n  // Regularize trailing context by the contextLines parameter\n  const regularizeTrailingContext = function (context) {\n    if (context.length === 0 || contextLines === 0) {\n      return []\n    }\n\n    return context.slice(0, Math.min(contextLines, context.length))\n  }\n\n  // Skip common lines in the beginning\n  while (i < oriLen && oriIsInLcs[i] === true && newIsInLcs[i] === true) {\n    leadingContext.push(oriLines[i])\n    i++\n  }\n\n  j = i\n  // The index in the longest common sequence\n  k = i\n  oriHunkStart = i\n  newHunkStart = j\n  oriHunkEnd = i\n  newHunkEnd = j\n\n  while (i < oriLen || j < newLen) {\n    while (i < oriLen && oriIsInLcs[i] === false) {\n      i++\n    }\n    oriHunkEnd = i\n\n    while (j < newLen && newIsInLcs[j] === false) {\n      j++\n    }\n    newHunkEnd = j\n\n    // Find the trailing context\n    trailingContext = []\n    while (i < oriLen && oriIsInLcs[i] === true && j < newLen && newIsInLcs[j] === true) {\n      trailingContext.push(oriLines[i])\n      k++\n      i++\n      j++\n    }\n\n    if (\n      k >= lcsLen || // No more in longest common lines\n      trailingContext.length >= 2 * contextLines\n    ) {\n      // Context break found\n      if (trailingContext.length < 2 * contextLines) {\n        // It must be last block of common lines but not a context break\n        trailingContext = []\n\n        // Force break out\n        i = oriLen\n        j = newLen\n\n        // Update hunk ends to force output to the end\n        oriHunkEnd = oriLen\n        newHunkEnd = newLen\n      }\n\n      // Output the diff hunk\n\n      // Trim the leading and trailing context block\n      actualLeadingContext = regularizeLeadingContext(leadingContext)\n      actualTrailingContext = regularizeTrailingContext(trailingContext)\n\n      oriHunkStart -= actualLeadingContext.length\n      newHunkStart -= actualLeadingContext.length\n      oriHunkEnd += actualTrailingContext.length\n      newHunkEnd += actualTrailingContext.length\n\n      oriHunkLineNo = oriHunkStart + 1\n      newHunkLineNo = newHunkStart + 1\n      oriHunkSize = oriHunkEnd - oriHunkStart\n      newHunkSize = newHunkEnd - newHunkStart\n\n      // Build header\n      unidiff += [\n        HEADER_PREFIX,\n        ORIGINAL_INDICATOR,\n        oriHunkLineNo,\n        RANGE_SEPARATOR,\n        oriHunkSize,\n        ' ',\n        NEW_INDICATOR,\n        newHunkLineNo,\n        RANGE_SEPARATOR,\n        newHunkSize,\n        HEADER_SUFFIX,\n        NEW_LINE,\n      ].join('')\n\n      // Build the diff hunk content\n      while (oriHunkStart < oriHunkEnd || newHunkStart < newHunkEnd) {\n        if (oriHunkStart < oriHunkEnd && oriIsInLcs[oriHunkStart] === true && newIsInLcs[newHunkStart] === true) {\n          // The context line\n          unidiff += CONTEXT_INDICATOR + oriLines[oriHunkStart] + NEW_LINE\n          oriHunkStart++\n          newHunkStart++\n        } else if (oriHunkStart < oriHunkEnd && oriIsInLcs[oriHunkStart] === false) {\n          // The deletion line\n          unidiff += DELETION_INDICATOR + oriLines[oriHunkStart] + NEW_LINE\n          oriHunkStart++\n        } else if (newHunkStart < newHunkEnd && newIsInLcs[newHunkStart] === false) {\n          // The additional line\n          unidiff += ADDITION_INDICATOR + newLines[newHunkStart] + NEW_LINE\n          newHunkStart++\n        }\n      }\n\n      // Update hunk position and leading context\n      oriHunkStart = i\n      newHunkStart = j\n      leadingContext = trailingContext\n    }\n  }\n\n  // Trim the trailing new line if it exists\n  if (unidiff.length > 0 && unidiff.charAt(unidiff.length) === NEW_LINE) {\n    unidiff = unidiff.slice(0, -1)\n  }\n\n  return unidiff\n}\n"]}