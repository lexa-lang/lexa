{"version":3,"sources":["../../../src/php/strings/wordwrap.js"],"names":["module","exports","wordwrap","str","intWidth","strBreak","cut","arguments","length","i","j","line","reLineBreaks","reBeginningUntilFirstWhitespace","reLastCharsWithOptionalTrailingWhitespace","lines","split","l","match","slice","ltrim","rtrim","charsUntilNextWhitespace","join"],"mappings":";;AAAAA,OAAOC,OAAP,GAAiB,SAASC,QAAT,CAAkBC,GAAlB,EAAuBC,QAAvB,EAAiCC,QAAjC,EAA2CC,GAA3C,EAAgD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAF,aAAWG,UAAUC,MAAV,IAAoB,CAApB,GAAwB,CAACJ,QAAzB,GAAoC,EAA/C;AACAC,aAAWE,UAAUC,MAAV,IAAoB,CAApB,GAAwB,KAAKH,QAA7B,GAAwC,IAAnD;AACAC,QAAMC,UAAUC,MAAV,IAAoB,CAApB,GAAwB,CAAC,CAACF,GAA1B,GAAgC,KAAtC;;AAEA,MAAIG,UAAJ;AAAA,MAAOC,UAAP;AAAA,MAAUC,aAAV;;AAEAR,SAAO,EAAP;;AAEA,MAAIC,WAAW,CAAf,EAAkB;AAChB,WAAOD,GAAP;AACD;;AAED,MAAMS,eAAe,YAArB;AACA,MAAMC,kCAAkC,MAAxC;AACA,MAAMC,4CAA4C,WAAlD;;AAEA,MAAMC,QAAQZ,IAAIa,KAAJ,CAAUJ,YAAV,CAAd;AACA,MAAMK,IAAIF,MAAMP,MAAhB;AACA,MAAIU,cAAJ;;AAEA;AACA,OAAKT,IAAI,CAAT,EAAYA,IAAIQ,CAAhB,EAAmBF,MAAMN,GAAN,KAAcE,IAAjC,EAAuC;AACrCA,WAAOI,MAAMN,CAAN,CAAP;AACAM,UAAMN,CAAN,IAAW,EAAX;;AAEA,WAAOE,KAAKH,MAAL,GAAcJ,QAArB,EAA+B;AAC7B;AACA,UAAMe,QAAQR,KAAKQ,KAAL,CAAW,CAAX,EAAcf,WAAW,CAAzB,CAAd;;AAEA;AACA,UAAIgB,QAAQ,CAAZ;AACA;AACA,UAAIC,QAAQ,CAAZ;;AAEAH,cAAQC,MAAMD,KAAN,CAAYJ,yCAAZ,CAAR;;AAEA;AACA,UAAII,MAAM,CAAN,CAAJ,EAAc;AACZ;AACAR,YAAIN,QAAJ;AACAgB,gBAAQ,CAAR;AACD,OAJD,MAIO;AACL;AACAV,YAAIS,MAAMX,MAAN,GAAeU,MAAM,CAAN,EAASV,MAA5B;;AAEA,YAAIE,CAAJ,EAAO;AACLW,kBAAQ,CAAR;AACD;;AAED;AACA;AACA;AACA,YAAI,CAACX,CAAD,IAAMJ,GAAN,IAAaF,QAAjB,EAA2B;AACzBM,cAAIN,QAAJ;AACD;;AAED;AACA;AACA,YAAI,CAACM,CAAL,EAAQ;AACN,cAAMY,2BAA2B,CAACX,KAAKQ,KAAL,CAAWf,QAAX,EAAqBc,KAArB,CAA2BL,+BAA3B,KAA+D,CAAC,EAAD,CAAhE,EAAsE,CAAtE,CAAjC;;AAEAH,cAAIS,MAAMX,MAAN,GAAec,yBAAyBd,MAA5C;AACD;AACF;;AAEDO,YAAMN,CAAN,KAAYE,KAAKQ,KAAL,CAAW,CAAX,EAAcT,IAAIW,KAAlB,CAAZ;AACAV,aAAOA,KAAKQ,KAAL,CAAWT,IAAIU,KAAf,CAAP;AACAL,YAAMN,CAAN,KAAYE,KAAKH,MAAL,GAAcH,QAAd,GAAyB,EAArC;AACD;AACF;;AAED,SAAOU,MAAMQ,IAAN,CAAW,IAAX,CAAP;AACD,CAzFD","file":"wordwrap.js","sourcesContent":["module.exports = function wordwrap(str, intWidth, strBreak, cut) {\n  //  discuss at: https://locutus.io/php/wordwrap/\n  // original by: Jonas Raoni Soares Silva (https://www.jsfromhell.com)\n  // improved by: Nick Callen\n  // improved by: Kevin van Zonneveld (https://kvz.io)\n  // improved by: Sakimori\n  //  revised by: Jonas Raoni Soares Silva (https://www.jsfromhell.com)\n  // bugfixed by: Michael Grier\n  // bugfixed by: Feras ALHAEK\n  // improved by: Rafa≈Ç Kukawski (https://kukawski.net)\n  //   example 1: wordwrap('Kevin van Zonneveld', 6, '|', true)\n  //   returns 1: 'Kevin|van|Zonnev|eld'\n  //   example 2: wordwrap('The quick brown fox jumped over the lazy dog.', 20, '<br />\\n')\n  //   returns 2: 'The quick brown fox<br />\\njumped over the lazy<br />\\ndog.'\n  //   example 3: wordwrap('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.')\n  //   returns 3: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod\\ntempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\\nveniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\\ncommodo consequat.'\n\n  intWidth = arguments.length >= 2 ? +intWidth : 75\n  strBreak = arguments.length >= 3 ? '' + strBreak : '\\n'\n  cut = arguments.length >= 4 ? !!cut : false\n\n  let i, j, line\n\n  str += ''\n\n  if (intWidth < 1) {\n    return str\n  }\n\n  const reLineBreaks = /\\r\\n|\\n|\\r/\n  const reBeginningUntilFirstWhitespace = /^\\S*/\n  const reLastCharsWithOptionalTrailingWhitespace = /\\S*(\\s)?$/\n\n  const lines = str.split(reLineBreaks)\n  const l = lines.length\n  let match\n\n  // for each line of text\n  for (i = 0; i < l; lines[i++] += line) {\n    line = lines[i]\n    lines[i] = ''\n\n    while (line.length > intWidth) {\n      // get slice of length one char above limit\n      const slice = line.slice(0, intWidth + 1)\n\n      // remove leading whitespace from rest of line to parse\n      let ltrim = 0\n      // remove trailing whitespace from new line content\n      let rtrim = 0\n\n      match = slice.match(reLastCharsWithOptionalTrailingWhitespace)\n\n      // if the slice ends with whitespace\n      if (match[1]) {\n        // then perfect moment to cut the line\n        j = intWidth\n        ltrim = 1\n      } else {\n        // otherwise cut at previous whitespace\n        j = slice.length - match[0].length\n\n        if (j) {\n          rtrim = 1\n        }\n\n        // but if there is no previous whitespace\n        // and cut is forced\n        // cut just at the defined limit\n        if (!j && cut && intWidth) {\n          j = intWidth\n        }\n\n        // if cut wasn't forced\n        // cut at next possible whitespace after the limit\n        if (!j) {\n          const charsUntilNextWhitespace = (line.slice(intWidth).match(reBeginningUntilFirstWhitespace) || [''])[0]\n\n          j = slice.length + charsUntilNextWhitespace.length\n        }\n      }\n\n      lines[i] += line.slice(0, j - rtrim)\n      line = line.slice(j + ltrim)\n      lines[i] += line.length ? strBreak : ''\n    }\n  }\n\n  return lines.join('\\n')\n}\n"]}