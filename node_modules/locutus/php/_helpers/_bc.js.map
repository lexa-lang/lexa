{"version":3,"sources":["../../../src/php/_helpers/_bc.js"],"names":["module","exports","_bc","Libbcmath","PLUS","MINUS","BASE","scale","bc_num","n_sign","n_len","n_scale","n_value","toString","r","tmp","join","substr","bc_add","n1","n2","scaleMin","sum","cmpRes","resScale","_bc_do_add","_bc_do_compare","_bc_do_sub","MAX","bc_new_num","memset","bc_compare","_one_mult","num","nPtr","size","digit","result","rPtr","carry","value","nptr","rptr","memcpy","Math","floor","bc_divide","qval","num1","num2","ptr1","ptr2","n2ptr","qptr","scale1","val","len1","len2","scale2","qdigits","extra","count","qdig","qguess","borrow","mval","zero","norm","bc_is_zero","MIN","safe_emalloc","bc_out_of_memory","_bc_rm_leading_zeros","MUL_BASE_DIGITS","MUL_SMALL_DIGITS","bc_multiply","pval","fullScale","prodScale","_bc_rec_mul","new_sub_num","length","ptr","temp","_bc_simp_mul","n1len","n2len","prod","n1ptr","pvptr","n1end","n2end","indx","prodlen","_bc_shift_addsub","accum","shift","sub","accp","valp","Error","u","ulen","v","vlen","u0","u1","v0","v1","m1","m2","m3","d1","d2","n","m1zero","d1len","d2len","bc_init_num","bc_sub","useSign","ignoreLast","min","diff","sumScale","sumDigits","sumptr","n1bytes","n2bytes","diffScale","diffLen","minScale","minLen","diffptr","len","Array","php_str2num","str","p","indexOf","bc_str2num","CH_VAL","c","BCD_CHAR","d","isdigit","isNaN","parseInt","strIn","digits","strscale","zeroInt","split","cint","x","a","b","ODD","chr","i","dest","src","srcptr"],"mappings":"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","file":"_bc.js","sourcesContent":["module.exports = function _bc() {\n  //  discuss at: https://locutus.io/php/_helpers/_bc\n  // original by: lmeyrick (https://sourceforge.net/projects/bcmath-js/)\n  // improved by: Brett Zamir (https://brett-zamir.me)\n  //   example 1: var $bc = _bc()\n  //   example 1: var $result = $bc.PLUS\n  //   returns 1: '+'\n\n  /**\n   * BC Math Library for Javascript\n   * Ported from the PHP5 bcmath extension source code,\n   * which uses the Libbcmath package...\n   *    Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.\n   *    Copyright (C) 2000 Philip A. Nelson\n   *     The Free Software Foundation, Inc.\n   *     59 Temple Place, Suite 330\n   *     Boston, MA 02111-1307 USA.\n   *      e-mail:  philnelson@acm.org\n   *     us-mail:  Philip A. Nelson\n   *               Computer Science Department, 9062\n   *               Western Washington University\n   *               Bellingham, WA 98226-9062\n   *\n   * bcmath-js homepage:\n   *\n   * This code is covered under the LGPL licence, and can be used however you want :)\n   * Be kind and share any decent code changes.\n   */\n\n  /**\n   * Binary Calculator (BC) Arbitrary Precision Mathematics Lib v0.10  (LGPL)\n   * Copy of Libbcmath included in PHP5 src\n   *\n   * Note: this is just the shared library file and does not include the php-style functions.\n   *       use bcmath{-min}.js for functions like bcadd, bcsub etc.\n   *\n   * Feel free to use how-ever you want, just email any bug-fixes/improvements\n   * to the sourceforge project:\n   *\n   *\n   * Ported from the PHP5 bcmath extension source code,\n   * which uses the Libbcmath package...\n   *    Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.\n   *    Copyright (C) 2000 Philip A. Nelson\n   *     The Free Software Foundation, Inc.\n   *     59 Temple Place, Suite 330\n   *     Boston, MA 02111-1307 USA.\n   *      e-mail:  philnelson@acm.org\n   *     us-mail:  Philip A. Nelson\n   *               Computer Science Department, 9062\n   *               Western Washington University\n   *               Bellingham, WA 98226-9062\n   */\n\n  var Libbcmath = {\n    PLUS: '+',\n    MINUS: '-',\n    BASE: 10,\n    // must be 10 (for now)\n    scale: 0,\n    // default scale\n    /**\n     * Basic number structure\n     */\n    bc_num: function () {\n      this.n_sign = null // sign\n      this.n_len = null // (int) The number of digits before the decimal point.\n      this.n_scale = null // (int) The number of digits after the decimal point.\n      // this.n_refs = null; // (int) The number of pointers to this number.\n      // this.n_text = null; // ?? Linked list for available list.\n      this.n_value = null // array as value, where 1.23 = [1,2,3]\n      this.toString = function () {\n        let r, tmp\n        tmp = this.n_value.join('')\n\n        // add minus sign (if applicable) then add the integer part\n        r = (this.n_sign === Libbcmath.PLUS ? '' : this.n_sign) + tmp.substr(0, this.n_len)\n\n        // if decimal places, add a . and the decimal part\n        if (this.n_scale > 0) {\n          r += '.' + tmp.substr(this.n_len, this.n_scale)\n        }\n        return r\n      }\n    },\n\n    /**\n     * Base add function\n     *\n     //  Here is the full add routine that takes care of negative numbers.\n     //  N1 is added to N2 and the result placed into RESULT.  SCALE_MIN\n     //  is the minimum scale for the result.\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {int} scaleMin\n     * @return bc_num\n     */\n    bc_add: function (n1, n2, scaleMin) {\n      let sum, cmpRes, resScale\n\n      if (n1.n_sign === n2.n_sign) {\n        sum = Libbcmath._bc_do_add(n1, n2, scaleMin)\n        sum.n_sign = n1.n_sign\n      } else {\n        // subtraction must be done.\n        cmpRes = Libbcmath._bc_do_compare(n1, n2, false, false) // Compare magnitudes.\n        switch (cmpRes) {\n          case -1:\n            // n1 is less than n2, subtract n1 from n2.\n            sum = Libbcmath._bc_do_sub(n2, n1, scaleMin)\n            sum.n_sign = n2.n_sign\n            break\n\n          case 0:\n            // They are equal! return zero with the correct scale!\n            resScale = Libbcmath.MAX(scaleMin, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n            sum = Libbcmath.bc_new_num(1, resScale)\n            Libbcmath.memset(sum.n_value, 0, 0, resScale + 1)\n            break\n\n          case 1:\n            // n2 is less than n1, subtract n2 from n1.\n            sum = Libbcmath._bc_do_sub(n1, n2, scaleMin)\n            sum.n_sign = n1.n_sign\n        }\n      }\n      return sum\n    },\n\n    /**\n     * This is the \"user callable\" routine to compare numbers N1 and N2.\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @return int -1, 0, 1  (n1 < n2, ===, n1 > n2)\n     */\n    bc_compare: function (n1, n2) {\n      return Libbcmath._bc_do_compare(n1, n2, true, false)\n    },\n\n    _one_mult: function (num, nPtr, size, digit, result, rPtr) {\n      let carry, value // int\n      let nptr, rptr // int pointers\n      if (digit === 0) {\n        Libbcmath.memset(result, 0, 0, size) // memset (result, 0, size);\n      } else {\n        if (digit === 1) {\n          Libbcmath.memcpy(result, rPtr, num, nPtr, size) // memcpy (result, num, size);\n        } else {\n          // Initialize\n          nptr = nPtr + size - 1 // nptr = (unsigned char *) (num+size-1);\n          rptr = rPtr + size - 1 // rptr = (unsigned char *) (result+size-1);\n          carry = 0\n\n          while (size-- > 0) {\n            value = num[nptr--] * digit + carry // value = *nptr-- * digit + carry;\n            result[rptr--] = value % Libbcmath.BASE // @CHECK cint //*rptr-- = value % BASE;\n            carry = Math.floor(value / Libbcmath.BASE) // @CHECK cint //carry = value / BASE;\n          }\n\n          if (carry !== 0) {\n            result[rptr] = carry\n          }\n        }\n      }\n    },\n\n    bc_divide: function (n1, n2, scale) {\n      // var quot // bc_num return\n      let qval // bc_num\n      let num1, num2 // string\n      let ptr1, ptr2, n2ptr, qptr // int pointers\n      let scale1, val // int\n      let len1, len2, scale2, qdigits, extra, count // int\n      let qdig, qguess, borrow, carry // int\n      let mval // string\n      let zero // char\n      let norm // int\n      // var ptrs // return object from one_mul\n      // Test for divide by zero. (return failure)\n      if (Libbcmath.bc_is_zero(n2)) {\n        return -1\n      }\n\n      // Test for zero divide by anything (return zero)\n      if (Libbcmath.bc_is_zero(n1)) {\n        return Libbcmath.bc_new_num(1, scale)\n      }\n\n      /* Test for n1 equals n2 (return 1 as n1 nor n2 are zero)\n        if (Libbcmath.bc_compare(n1, n2, Libbcmath.MAX(n1.n_scale, n2.n_scale)) === 0) {\n          quot=Libbcmath.bc_new_num(1, scale);\n          quot.n_value[0] = 1;\n          return quot;\n        }\n      */\n\n      // Test for divide by 1.  If it is we must truncate.\n      // @todo: check where scale > 0 too.. can't see why not\n      // (ie bc_is_zero - add bc_is_one function)\n      if (n2.n_scale === 0) {\n        if (n2.n_len === 1 && n2.n_value[0] === 1) {\n          qval = Libbcmath.bc_new_num(n1.n_len, scale) // qval = bc_new_num (n1->n_len, scale);\n          qval.n_sign = n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS\n          // memset (&qval->n_value[n1->n_len],0,scale):\n          Libbcmath.memset(qval.n_value, n1.n_len, 0, scale)\n          // memcpy (qval->n_value, n1->n_value, n1->n_len + MIN(n1->n_scale,scale)):\n          Libbcmath.memcpy(qval.n_value, 0, n1.n_value, 0, n1.n_len + Libbcmath.MIN(n1.n_scale, scale))\n          // can we return here? not in c src, but can't see why-not.\n          // return qval;\n        }\n      }\n\n      /* Set up the divide.  Move the decimal point on n1 by n2's scale.\n       Remember, zeros on the end of num2 are wasted effort for dividing. */\n      scale2 = n2.n_scale // scale2 = n2->n_scale;\n      n2ptr = n2.n_len + scale2 - 1 // n2ptr = (unsigned char *) n2.n_value+n2.n_len+scale2-1;\n      while (scale2 > 0 && n2.n_value[n2ptr--] === 0) {\n        scale2--\n      }\n\n      len1 = n1.n_len + scale2\n      scale1 = n1.n_scale - scale2\n      if (scale1 < scale) {\n        extra = scale - scale1\n      } else {\n        extra = 0\n      }\n\n      // num1 = (unsigned char *) safe_emalloc (1, n1.n_len+n1.n_scale, extra+2):\n      num1 = Libbcmath.safe_emalloc(1, n1.n_len + n1.n_scale, extra + 2)\n      if (num1 === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n      // memset (num1, 0, n1->n_len+n1->n_scale+extra+2):\n      Libbcmath.memset(num1, 0, 0, n1.n_len + n1.n_scale + extra + 2)\n      // memcpy (num1+1, n1.n_value, n1.n_len+n1.n_scale):\n      Libbcmath.memcpy(num1, 1, n1.n_value, 0, n1.n_len + n1.n_scale)\n      // len2 = n2->n_len + scale2:\n      len2 = n2.n_len + scale2\n      // num2 = (unsigned char *) safe_emalloc (1, len2, 1):\n      num2 = Libbcmath.safe_emalloc(1, len2, 1)\n      if (num2 === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n      // memcpy (num2, n2.n_value, len2):\n      Libbcmath.memcpy(num2, 0, n2.n_value, 0, len2)\n      // *(num2+len2) = 0:\n      num2[len2] = 0\n      // n2ptr = num2:\n      n2ptr = 0\n      // while (*n2ptr === 0):\n      while (num2[n2ptr] === 0) {\n        n2ptr++\n        len2--\n      }\n\n      // Calculate the number of quotient digits.\n      if (len2 > len1 + scale) {\n        qdigits = scale + 1\n        zero = true\n      } else {\n        zero = false\n        if (len2 > len1) {\n          qdigits = scale + 1 // One for the zero integer part.\n        } else {\n          qdigits = len1 - len2 + scale + 1\n        }\n      }\n\n      // Allocate and zero the storage for the quotient.\n      // qval = bc_new_num (qdigits-scale,scale);\n      qval = Libbcmath.bc_new_num(qdigits - scale, scale)\n      // memset (qval->n_value, 0, qdigits);\n      Libbcmath.memset(qval.n_value, 0, 0, qdigits)\n      // Allocate storage for the temporary storage mval.\n      // mval = (unsigned char *) safe_emalloc (1, len2, 1);\n      mval = Libbcmath.safe_emalloc(1, len2, 1)\n      if (mval === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n\n      // Now for the full divide algorithm.\n      if (!zero) {\n        // Normalize\n        // norm = Libbcmath.cint(10 / (Libbcmath.cint(n2.n_value[n2ptr]) + 1));\n        // norm =  10 / ((int)*n2ptr + 1)\n        norm = Math.floor(10 / (n2.n_value[n2ptr] + 1)) // norm =  10 / ((int)*n2ptr + 1);\n        if (norm !== 1) {\n          // Libbcmath._one_mult(num1, len1+scale1+extra+1, norm, num1);\n          Libbcmath._one_mult(num1, 0, len1 + scale1 + extra + 1, norm, num1, 0)\n          // Libbcmath._one_mult(n2ptr, len2, norm, n2ptr);\n          Libbcmath._one_mult(n2.n_value, n2ptr, len2, norm, n2.n_value, n2ptr)\n          // @todo: Check: Is the pointer affected by the call? if so,\n          // maybe need to adjust points on return?\n        }\n\n        // Initialize divide loop.\n        qdig = 0\n        if (len2 > len1) {\n          qptr = len2 - len1 // qptr = (unsigned char *) qval.n_value+len2-len1;\n        } else {\n          qptr = 0 // qptr = (unsigned char *) qval.n_value;\n        }\n\n        // Loop\n        while (qdig <= len1 + scale - len2) {\n          // Calculate the quotient digit guess.\n          if (n2.n_value[n2ptr] === num1[qdig]) {\n            qguess = 9\n          } else {\n            qguess = Math.floor((num1[qdig] * 10 + num1[qdig + 1]) / n2.n_value[n2ptr])\n          }\n          // Test qguess.\n\n          if (\n            n2.n_value[n2ptr + 1] * qguess >\n            (num1[qdig] * 10 + num1[qdig + 1] - n2.n_value[n2ptr] * qguess) * 10 + num1[qdig + 2]\n          ) {\n            qguess--\n            // And again.\n            if (\n              n2.n_value[n2ptr + 1] * qguess >\n              (num1[qdig] * 10 + num1[qdig + 1] - n2.n_value[n2ptr] * qguess) * 10 + num1[qdig + 2]\n            ) {\n              qguess--\n            }\n          }\n\n          // Multiply and subtract.\n          borrow = 0\n          if (qguess !== 0) {\n            mval[0] = 0 //* mval = 0; // @CHECK is this to fix ptr2 < 0?\n            // _one_mult (n2ptr, len2, qguess, mval+1); // @CHECK\n            Libbcmath._one_mult(n2.n_value, n2ptr, len2, qguess, mval, 1)\n            ptr1 = qdig + len2 // (unsigned char *) num1+qdig+len2;\n            ptr2 = len2 // (unsigned char *) mval+len2;\n            // @todo: CHECK: Does a negative pointer return null?\n            // ptr2 can be < 0 here as ptr1 = len2, thus count < len2+1 will always fail ?\n            for (count = 0; count < len2 + 1; count++) {\n              if (ptr2 < 0) {\n                // val = Libbcmath.cint(num1[ptr1]) - 0 - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                val = num1[ptr1] - 0 - borrow // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n              } else {\n                // val = Libbcmath.cint(num1[ptr1]) - Libbcmath.cint(mval[ptr2--]) - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                val = num1[ptr1] - mval[ptr2--] - borrow\n              }\n              if (val < 0) {\n                val += 10\n                borrow = 1\n              } else {\n                borrow = 0\n              }\n              num1[ptr1--] = val\n            }\n          }\n\n          // Test for negative result.\n          if (borrow === 1) {\n            qguess--\n            ptr1 = qdig + len2 // (unsigned char *) num1+qdig+len2;\n            ptr2 = len2 - 1 // (unsigned char *) n2ptr+len2-1;\n            carry = 0\n            for (count = 0; count < len2; count++) {\n              if (ptr2 < 0) {\n                // val = Libbcmath.cint(num1[ptr1]) + 0 + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                val = num1[ptr1] + 0 + carry\n              } else {\n                // val = Libbcmath.cint(num1[ptr1]) + Libbcmath.cint(n2.n_value[ptr2--]) + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                val = num1[ptr1] + n2.n_value[ptr2--] + carry\n              }\n              if (val > 9) {\n                val -= 10\n                carry = 1\n              } else {\n                carry = 0\n              }\n              num1[ptr1--] = val //* ptr1-- = val;\n            }\n            if (carry === 1) {\n              // num1[ptr1] = Libbcmath.cint((num1[ptr1] + 1) % 10);\n              // *ptr1 = (*ptr1 + 1) % 10; // @CHECK\n              // *ptr1 = (*ptr1 + 1) % 10; // @CHECK\n              num1[ptr1] = (num1[ptr1] + 1) % 10\n            }\n          }\n\n          // We now know the quotient digit.\n          qval.n_value[qptr++] = qguess //* qptr++ =  qguess;\n          qdig++\n        }\n      }\n\n      // Clean up and return the number.\n      qval.n_sign = n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS\n      if (Libbcmath.bc_is_zero(qval)) {\n        qval.n_sign = Libbcmath.PLUS\n      }\n      Libbcmath._bc_rm_leading_zeros(qval)\n\n      return qval\n\n      // return 0;    // Everything is OK.\n    },\n\n    MUL_BASE_DIGITS: 80,\n    MUL_SMALL_DIGITS: 80 / 4,\n    // #define MUL_SMALL_DIGITS mul_base_digits/4\n\n    /* The multiply routine.  N2 times N1 is put int PROD with the scale of\n   the result being MIN(N2 scale+N1 scale, MAX (SCALE, N2 scale, N1 scale)).\n   */\n    /**\n     * @param n1 bc_num\n     * @param n2 bc_num\n     * @param scale [int] optional\n     */\n    bc_multiply: function (n1, n2, scale) {\n      let pval // bc_num\n      let len1, len2 // int\n      let fullScale, prodScale // int\n      // Initialize things.\n      len1 = n1.n_len + n1.n_scale\n      len2 = n2.n_len + n2.n_scale\n      fullScale = n1.n_scale + n2.n_scale\n      prodScale = Libbcmath.MIN(fullScale, Libbcmath.MAX(scale, Libbcmath.MAX(n1.n_scale, n2.n_scale)))\n\n      // pval = Libbcmath.bc_init_num(); // allow pass by ref\n      // Do the multiply\n      pval = Libbcmath._bc_rec_mul(n1, len1, n2, len2, fullScale)\n\n      // Assign to prod and clean up the number.\n      pval.n_sign = n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS\n      // pval.n_value = pval.nPtr;\n      pval.n_len = len2 + len1 + 1 - fullScale\n      pval.n_scale = prodScale\n      Libbcmath._bc_rm_leading_zeros(pval)\n      if (Libbcmath.bc_is_zero(pval)) {\n        pval.n_sign = Libbcmath.PLUS\n      }\n      // bc_free_num (prod);\n      return pval\n    },\n\n    new_sub_num: function (length, scale, value, ptr = 0) {\n      const temp = new Libbcmath.bc_num() // eslint-disable-line new-cap\n      temp.n_sign = Libbcmath.PLUS\n      temp.n_len = length\n      temp.n_scale = scale\n      temp.n_value = Libbcmath.safe_emalloc(1, length + scale, 0)\n      Libbcmath.memcpy(temp.n_value, 0, value, ptr, length + scale)\n      return temp\n    },\n\n    _bc_simp_mul: function (n1, n1len, n2, n2len, fullScale) {\n      let prod // bc_num\n      let n1ptr, n2ptr, pvptr // char *n1ptr, *n2ptr, *pvptr;\n      let n1end, n2end // char *n1end, *n2end;        // To the end of n1 and n2.\n      let indx, sum, prodlen // int indx, sum, prodlen;\n      prodlen = n1len + n2len + 1\n\n      prod = Libbcmath.bc_new_num(prodlen, 0)\n\n      n1end = n1len - 1 // (char *) (n1->n_value + n1len - 1);\n      n2end = n2len - 1 // (char *) (n2->n_value + n2len - 1);\n      pvptr = prodlen - 1 // (char *) ((*prod)->n_value + prodlen - 1);\n      sum = 0\n\n      // Here is the loop...\n      for (indx = 0; indx < prodlen - 1; indx++) {\n        // (char *) (n1end - MAX(0, indx-n2len+1));\n        n1ptr = n1end - Libbcmath.MAX(0, indx - n2len + 1)\n        // (char *) (n2end - MIN(indx, n2len-1));\n        n2ptr = n2end - Libbcmath.MIN(indx, n2len - 1)\n        while (n1ptr >= 0 && n2ptr <= n2end) {\n          // sum += *n1ptr-- * *n2ptr++;\n          sum += n1.n_value[n1ptr--] * n2.n_value[n2ptr++]\n        }\n        //* pvptr-- = sum % BASE;\n        prod.n_value[pvptr--] = Math.floor(sum % Libbcmath.BASE)\n        sum = Math.floor(sum / Libbcmath.BASE) // sum = sum / BASE;\n      }\n      prod.n_value[pvptr] = sum //* pvptr = sum;\n      return prod\n    },\n\n    /* A special adder/subtractor for the recursive divide and conquer\n       multiply algorithm.  Note: if sub is called, accum must\n       be larger that what is being subtracted.  Also, accum and val\n       must have n_scale = 0.  (e.g. they must look like integers. *) */\n    _bc_shift_addsub: function (accum, val, shift, sub) {\n      let accp, valp // signed char *accp, *valp;\n      let count, carry // int  count, carry;\n      count = val.n_len\n      if (val.n_value[0] === 0) {\n        count--\n      }\n\n      // assert (accum->n_len+accum->n_scale >= shift+count);\n      if (accum.n_len + accum.n_scale < shift + count) {\n        throw new Error('len + scale < shift + count') // ?? I think that's what assert does :)\n      }\n\n      // Set up pointers and others\n      // (signed char *)(accum->n_value + accum->n_len + accum->n_scale - shift - 1);\n      accp = accum.n_len + accum.n_scale - shift - 1\n      valp = val.n_len - 1 // (signed char *)(val->n_value + val->n_len - 1);\n      carry = 0\n      if (sub) {\n        // Subtraction, carry is really borrow.\n        while (count--) {\n          accum.n_value[accp] -= val.n_value[valp--] + carry //* accp -= *valp-- + carry;\n          if (accum.n_value[accp] < 0) {\n            // if (*accp < 0)\n            carry = 1\n            accum.n_value[accp--] += Libbcmath.BASE //* accp-- += BASE;\n          } else {\n            carry = 0\n            accp--\n          }\n        }\n        while (carry) {\n          accum.n_value[accp] -= carry //* accp -= carry;\n          if (accum.n_value[accp] < 0) {\n            // if (*accp < 0)\n            accum.n_value[accp--] += Libbcmath.BASE //    *accp-- += BASE;\n          } else {\n            carry = 0\n          }\n        }\n      } else {\n        // Addition\n        while (count--) {\n          accum.n_value[accp] += val.n_value[valp--] + carry //* accp += *valp-- + carry;\n          if (accum.n_value[accp] > Libbcmath.BASE - 1) {\n            // if (*accp > (BASE-1))\n            carry = 1\n            accum.n_value[accp--] -= Libbcmath.BASE //* accp-- -= BASE;\n          } else {\n            carry = 0\n            accp--\n          }\n        }\n        while (carry) {\n          accum.n_value[accp] += carry //* accp += carry;\n          if (accum.n_value[accp] > Libbcmath.BASE - 1) {\n            // if (*accp > (BASE-1))\n            accum.n_value[accp--] -= Libbcmath.BASE //* accp-- -= BASE;\n          } else {\n            carry = 0\n          }\n        }\n      }\n      return true // accum is the pass-by-reference return\n    },\n\n    /* Recursive divide and conquer multiply algorithm.\n       based on\n       Let u = u0 + u1*(b^n)\n       Let v = v0 + v1*(b^n)\n       Then uv = (B^2n+B^n)*u1*v1 + B^n*(u1-u0)*(v0-v1) + (B^n+1)*u0*v0\n\n       B is the base of storage, number of digits in u1,u0 close to equal.\n    */\n    _bc_rec_mul: function (u, ulen, v, vlen, fullScale) {\n      let prod // @return\n      let u0, u1, v0, v1 // bc_num\n      // var u0len,\n      // var v0len // int\n      let m1, m2, m3, d1, d2 // bc_num\n      let n, prodlen, m1zero // int\n      let d1len, d2len // int\n      // Base case?\n      if (\n        ulen + vlen < Libbcmath.MUL_BASE_DIGITS ||\n        ulen < Libbcmath.MUL_SMALL_DIGITS ||\n        vlen < Libbcmath.MUL_SMALL_DIGITS\n      ) {\n        return Libbcmath._bc_simp_mul(u, ulen, v, vlen, fullScale)\n      }\n\n      // Calculate n -- the u and v split point in digits.\n      n = Math.floor((Libbcmath.MAX(ulen, vlen) + 1) / 2)\n\n      // Split u and v.\n      if (ulen < n) {\n        u1 = Libbcmath.bc_init_num() // u1 = bc_copy_num (BCG(_zero_));\n        u0 = Libbcmath.new_sub_num(ulen, 0, u.n_value)\n      } else {\n        u1 = Libbcmath.new_sub_num(ulen - n, 0, u.n_value)\n        u0 = Libbcmath.new_sub_num(n, 0, u.n_value, ulen - n)\n      }\n      if (vlen < n) {\n        v1 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n        v0 = Libbcmath.new_sub_num(vlen, 0, v.n_value)\n      } else {\n        v1 = Libbcmath.new_sub_num(vlen - n, 0, v.n_value)\n        v0 = Libbcmath.new_sub_num(n, 0, v.n_value, vlen - n)\n      }\n      Libbcmath._bc_rm_leading_zeros(u1)\n      Libbcmath._bc_rm_leading_zeros(u0)\n      // var u0len = u0.n_len\n      Libbcmath._bc_rm_leading_zeros(v1)\n      Libbcmath._bc_rm_leading_zeros(v0)\n      // var v0len = v0.n_len\n\n      m1zero = Libbcmath.bc_is_zero(u1) || Libbcmath.bc_is_zero(v1)\n\n      // Calculate sub results ...\n      d1 = Libbcmath.bc_init_num() // needed?\n      d2 = Libbcmath.bc_init_num() // needed?\n      d1 = Libbcmath.bc_sub(u1, u0, 0)\n      d1len = d1.n_len\n\n      d2 = Libbcmath.bc_sub(v0, v1, 0)\n      d2len = d2.n_len\n\n      // Do recursive multiplies and shifted adds.\n      if (m1zero) {\n        m1 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m1 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m1 = Libbcmath._bc_rec_mul(u1, u1.n_len, v1, v1.n_len, 0)\n      }\n      if (Libbcmath.bc_is_zero(d1) || Libbcmath.bc_is_zero(d2)) {\n        m2 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m2 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m2 = Libbcmath._bc_rec_mul(d1, d1len, d2, d2len, 0)\n      }\n\n      if (Libbcmath.bc_is_zero(u0) || Libbcmath.bc_is_zero(v0)) {\n        m3 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m3 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m3 = Libbcmath._bc_rec_mul(u0, u0.n_len, v0, v0.n_len, 0)\n      }\n\n      // Initialize product\n      prodlen = ulen + vlen + 1\n      prod = Libbcmath.bc_new_num(prodlen, 0)\n\n      if (!m1zero) {\n        Libbcmath._bc_shift_addsub(prod, m1, 2 * n, 0)\n        Libbcmath._bc_shift_addsub(prod, m1, n, 0)\n      }\n      Libbcmath._bc_shift_addsub(prod, m3, n, 0)\n      Libbcmath._bc_shift_addsub(prod, m3, 0, 0)\n      Libbcmath._bc_shift_addsub(prod, m2, n, d1.n_sign !== d2.n_sign)\n\n      return prod\n      // Now clean up!\n      // bc_free_num (&u1);\n      // bc_free_num (&u0);\n      // bc_free_num (&v1);\n      // bc_free_num (&m1);\n      // bc_free_num (&v0);\n      // bc_free_num (&m2);\n      // bc_free_num (&m3);\n      // bc_free_num (&d1);\n      // bc_free_num (&d2);\n    },\n\n    /**\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {boolean} useSign\n     * @param {boolean} ignoreLast\n     * @return -1, 0, 1 (see bc_compare)\n     */\n    _bc_do_compare: function (n1, n2, useSign, ignoreLast) {\n      let n1ptr, n2ptr // int\n      let count // int\n      // First, compare signs.\n      if (useSign && n1.n_sign !== n2.n_sign) {\n        if (n1.n_sign === Libbcmath.PLUS) {\n          return 1 // Positive N1 > Negative N2\n        } else {\n          return -1 // Negative N1 < Positive N1\n        }\n      }\n\n      // Now compare the magnitude.\n      if (n1.n_len !== n2.n_len) {\n        if (n1.n_len > n2.n_len) {\n          // Magnitude of n1 > n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return 1\n          } else {\n            return -1\n          }\n        } else {\n          // Magnitude of n1 < n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return -1\n          } else {\n            return 1\n          }\n        }\n      }\n\n      /* If we get here, they have the same number of integer digits.\n     check the integer part and the equal length part of the fraction. */\n      count = n1.n_len + Math.min(n1.n_scale, n2.n_scale)\n      n1ptr = 0\n      n2ptr = 0\n\n      while (count > 0 && n1.n_value[n1ptr] === n2.n_value[n2ptr]) {\n        n1ptr++\n        n2ptr++\n        count--\n      }\n\n      if (ignoreLast && count === 1 && n1.n_scale === n2.n_scale) {\n        return 0\n      }\n\n      if (count !== 0) {\n        if (n1.n_value[n1ptr] > n2.n_value[n2ptr]) {\n          // Magnitude of n1 > n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return 1\n          } else {\n            return -1\n          }\n        } else {\n          // Magnitude of n1 < n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return -1\n          } else {\n            return 1\n          }\n        }\n      }\n\n      // They are equal up to the last part of the equal part of the fraction.\n      if (n1.n_scale !== n2.n_scale) {\n        if (n1.n_scale > n2.n_scale) {\n          for (count = n1.n_scale - n2.n_scale; count > 0; count--) {\n            if (n1.n_value[n1ptr++] !== 0) {\n              // Magnitude of n1 > n2.\n              if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n                return 1\n              } else {\n                return -1\n              }\n            }\n          }\n        } else {\n          for (count = n2.n_scale - n1.n_scale; count > 0; count--) {\n            if (n2.n_value[n2ptr++] !== 0) {\n              // Magnitude of n1 < n2.\n              if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n                return -1\n              } else {\n                return 1\n              }\n            }\n          }\n        }\n      }\n\n      // They must be equal!\n      return 0\n    },\n\n    /* Here is the full subtract routine that takes care of negative numbers.\n   N2 is subtracted from N1 and the result placed in RESULT.  SCALE_MIN\n   is the minimum scale for the result. */\n    bc_sub: function (n1, n2, scaleMin) {\n      let diff // bc_num\n      let cmpRes, resScale // int\n      if (n1.n_sign !== n2.n_sign) {\n        diff = Libbcmath._bc_do_add(n1, n2, scaleMin)\n        diff.n_sign = n1.n_sign\n      } else {\n        // subtraction must be done.\n        // Compare magnitudes.\n        cmpRes = Libbcmath._bc_do_compare(n1, n2, false, false)\n        switch (cmpRes) {\n          case -1:\n            // n1 is less than n2, subtract n1 from n2.\n            diff = Libbcmath._bc_do_sub(n2, n1, scaleMin)\n            diff.n_sign = n2.n_sign === Libbcmath.PLUS ? Libbcmath.MINUS : Libbcmath.PLUS\n            break\n          case 0:\n            // They are equal! return zero!\n            resScale = Libbcmath.MAX(scaleMin, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n            diff = Libbcmath.bc_new_num(1, resScale)\n            Libbcmath.memset(diff.n_value, 0, 0, resScale + 1)\n            break\n          case 1:\n            // n2 is less than n1, subtract n2 from n1.\n            diff = Libbcmath._bc_do_sub(n1, n2, scaleMin)\n            diff.n_sign = n1.n_sign\n            break\n        }\n      }\n\n      // Clean up and return.\n      // bc_free_num (result);\n      //* result = diff;\n      return diff\n    },\n\n    _bc_do_add: function (n1, n2, scaleMin) {\n      let sum // bc_num\n      let sumScale, sumDigits // int\n      let n1ptr, n2ptr, sumptr // int\n      let carry, n1bytes, n2bytes // int\n      let tmp // int\n\n      // Prepare sum.\n      sumScale = Libbcmath.MAX(n1.n_scale, n2.n_scale)\n      sumDigits = Libbcmath.MAX(n1.n_len, n2.n_len) + 1\n      sum = Libbcmath.bc_new_num(sumDigits, Libbcmath.MAX(sumScale, scaleMin))\n\n      // Start with the fraction part.  Initialize the pointers.\n      n1bytes = n1.n_scale\n      n2bytes = n2.n_scale\n      n1ptr = n1.n_len + n1bytes - 1\n      n2ptr = n2.n_len + n2bytes - 1\n      sumptr = sumScale + sumDigits - 1\n\n      // Add the fraction part.  First copy the longer fraction\n      // (ie when adding 1.2345 to 1 we know .2345 is correct already) .\n      if (n1bytes !== n2bytes) {\n        if (n1bytes > n2bytes) {\n          // n1 has more dp then n2\n          while (n1bytes > n2bytes) {\n            sum.n_value[sumptr--] = n1.n_value[n1ptr--]\n            // *sumptr-- = *n1ptr--;\n            n1bytes--\n          }\n        } else {\n          // n2 has more dp then n1\n          while (n2bytes > n1bytes) {\n            sum.n_value[sumptr--] = n2.n_value[n2ptr--]\n            // *sumptr-- = *n2ptr--;\n            n2bytes--\n          }\n        }\n      }\n\n      // Now add the remaining fraction part and equal size integer parts.\n      n1bytes += n1.n_len\n      n2bytes += n2.n_len\n      carry = 0\n      while (n1bytes > 0 && n2bytes > 0) {\n        // add the two numbers together\n        tmp = n1.n_value[n1ptr--] + n2.n_value[n2ptr--] + carry\n        // *sumptr = *n1ptr-- + *n2ptr-- + carry;\n        // check if they are >= 10 (impossible to be more then 18)\n        if (tmp >= Libbcmath.BASE) {\n          carry = 1\n          tmp -= Libbcmath.BASE // yep, subtract 10, add a carry\n        } else {\n          carry = 0\n        }\n        sum.n_value[sumptr] = tmp\n        sumptr--\n        n1bytes--\n        n2bytes--\n      }\n\n      // Now add carry the [rest of the] longer integer part.\n      if (n1bytes === 0) {\n        // n2 is a bigger number then n1\n        while (n2bytes-- > 0) {\n          tmp = n2.n_value[n2ptr--] + carry\n          // *sumptr = *n2ptr-- + carry;\n          if (tmp >= Libbcmath.BASE) {\n            carry = 1\n            tmp -= Libbcmath.BASE\n          } else {\n            carry = 0\n          }\n          sum.n_value[sumptr--] = tmp\n        }\n      } else {\n        // n1 is bigger then n2..\n        while (n1bytes-- > 0) {\n          tmp = n1.n_value[n1ptr--] + carry\n          // *sumptr = *n1ptr-- + carry;\n          if (tmp >= Libbcmath.BASE) {\n            carry = 1\n            tmp -= Libbcmath.BASE\n          } else {\n            carry = 0\n          }\n          sum.n_value[sumptr--] = tmp\n        }\n      }\n\n      // Set final carry.\n      if (carry === 1) {\n        sum.n_value[sumptr] += 1\n        // *sumptr += 1;\n      }\n\n      // Adjust sum and return.\n      Libbcmath._bc_rm_leading_zeros(sum)\n      return sum\n    },\n\n    /**\n     * Perform a subtraction\n     *\n     * Perform subtraction: N2 is subtracted from N1 and the value is\n     *  returned.  The signs of N1 and N2 are ignored.  Also, N1 is\n     *  assumed to be larger than N2.  SCALE_MIN is the minimum scale\n     *  of the result.\n     *\n     * Basic school maths says to subtract 2 numbers..\n     * 1. make them the same length, the decimal places, and the integer part\n     * 2. start from the right and subtract the two numbers from each other\n     * 3. if the sum of the 2 numbers < 0, carry -1 to the next set and add 10\n     * (ie 18 > carry 1 becomes 8). thus 0.9 + 0.9 = 1.8\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {int} scaleMin\n     * @return bc_num\n     */\n    _bc_do_sub: function (n1, n2, scaleMin) {\n      let diff // bc_num\n      let diffScale, diffLen // int\n      let minScale, minLen // int\n      let n1ptr, n2ptr, diffptr // int\n      let borrow, count, val // int\n      // Allocate temporary storage.\n      diffLen = Libbcmath.MAX(n1.n_len, n2.n_len)\n      diffScale = Libbcmath.MAX(n1.n_scale, n2.n_scale)\n      minLen = Libbcmath.MIN(n1.n_len, n2.n_len)\n      minScale = Libbcmath.MIN(n1.n_scale, n2.n_scale)\n      diff = Libbcmath.bc_new_num(diffLen, Libbcmath.MAX(diffScale, scaleMin))\n\n      /* Not needed?\n      // Zero extra digits made by scaleMin.\n      if (scaleMin > diffScale) {\n        diffptr = (char *) (diff->n_value + diffLen + diffScale);\n        for (count = scaleMin - diffScale; count > 0; count--) {\n          *diffptr++ = 0;\n        }\n      }\n      */\n\n      // Initialize the subtract.\n      n1ptr = n1.n_len + n1.n_scale - 1\n      n2ptr = n2.n_len + n2.n_scale - 1\n      diffptr = diffLen + diffScale - 1\n\n      // Subtract the numbers.\n      borrow = 0\n\n      // Take care of the longer scaled number.\n      if (n1.n_scale !== minScale) {\n        // n1 has the longer scale\n        for (count = n1.n_scale - minScale; count > 0; count--) {\n          diff.n_value[diffptr--] = n1.n_value[n1ptr--]\n          // *diffptr-- = *n1ptr--;\n        }\n      } else {\n        // n2 has the longer scale\n        for (count = n2.n_scale - minScale; count > 0; count--) {\n          val = 0 - n2.n_value[n2ptr--] - borrow\n          // val = - *n2ptr-- - borrow;\n          if (val < 0) {\n            val += Libbcmath.BASE\n            borrow = 1\n          } else {\n            borrow = 0\n          }\n          diff.n_value[diffptr--] = val\n          //* diffptr-- = val;\n        }\n      }\n\n      // Now do the equal length scale and integer parts.\n      for (count = 0; count < minLen + minScale; count++) {\n        val = n1.n_value[n1ptr--] - n2.n_value[n2ptr--] - borrow\n        // val = *n1ptr-- - *n2ptr-- - borrow;\n        if (val < 0) {\n          val += Libbcmath.BASE\n          borrow = 1\n        } else {\n          borrow = 0\n        }\n        diff.n_value[diffptr--] = val\n        //* diffptr-- = val;\n      }\n\n      // If n1 has more digits then n2, we now do that subtract.\n      if (diffLen !== minLen) {\n        for (count = diffLen - minLen; count > 0; count--) {\n          val = n1.n_value[n1ptr--] - borrow\n          // val = *n1ptr-- - borrow;\n          if (val < 0) {\n            val += Libbcmath.BASE\n            borrow = 1\n          } else {\n            borrow = 0\n          }\n          diff.n_value[diffptr--] = val\n        }\n      }\n\n      // Clean up and return.\n      Libbcmath._bc_rm_leading_zeros(diff)\n      return diff\n    },\n\n    /**\n     *\n     * @param {int} length\n     * @param {int} scale\n     * @return bc_num\n     */\n    bc_new_num: function (length, scale) {\n      let temp // bc_num\n      temp = new Libbcmath.bc_num() // eslint-disable-line new-cap\n      temp.n_sign = Libbcmath.PLUS\n      temp.n_len = length\n      temp.n_scale = scale\n      temp.n_value = Libbcmath.safe_emalloc(1, length + scale, 0)\n      Libbcmath.memset(temp.n_value, 0, 0, length + scale)\n      return temp\n    },\n\n    safe_emalloc: function (size, len, extra) {\n      return Array(size * len + extra)\n    },\n\n    /**\n     * Create a new number\n     */\n    bc_init_num: function () {\n      return new Libbcmath.bc_new_num(1, 0) // eslint-disable-line new-cap\n    },\n\n    _bc_rm_leading_zeros: function (num) {\n      // We can move n_value to point to the first non zero digit!\n      while (num.n_value[0] === 0 && num.n_len > 1) {\n        num.n_value.shift()\n        num.n_len--\n      }\n    },\n\n    /**\n     * Convert to bc_num detecting scale\n     */\n    php_str2num: function (str) {\n      let p\n      p = str.indexOf('.')\n      if (p === -1) {\n        return Libbcmath.bc_str2num(str, 0)\n      } else {\n        return Libbcmath.bc_str2num(str, str.length - p)\n      }\n    },\n\n    CH_VAL: function (c) {\n      return c - '0' // ??\n    },\n\n    BCD_CHAR: function (d) {\n      return d + '0' // ??\n    },\n\n    isdigit: function (c) {\n      return isNaN(parseInt(c, 10))\n    },\n\n    bc_str2num: function (strIn, scale) {\n      let str, num, ptr, digits, strscale, zeroInt, nptr\n      // remove any non-expected characters\n      // Check for valid number and count digits.\n\n      str = strIn.split('') // convert to array\n      ptr = 0 // str\n      digits = 0\n      strscale = 0\n      zeroInt = false\n      if (str[ptr] === '+' || str[ptr] === '-') {\n        ptr++ // Sign\n      }\n      while (str[ptr] === '0') {\n        ptr++ // Skip leading zeros.\n      }\n      // while (Libbcmath.isdigit(str[ptr])) {\n      while (str[ptr] % 1 === 0) {\n        // Libbcmath.isdigit(str[ptr])) {\n        ptr++\n        digits++ // digits\n      }\n\n      if (str[ptr] === '.') {\n        ptr++ // decimal point\n      }\n      // while (Libbcmath.isdigit(str[ptr])) {\n      while (str[ptr] % 1 === 0) {\n        // Libbcmath.isdigit(str[ptr])) {\n        ptr++\n        strscale++ // digits\n      }\n\n      if (str[ptr] || digits + strscale === 0) {\n        // invalid number, return 0\n        return Libbcmath.bc_init_num()\n        //* num = bc_copy_num (BCG(_zero_));\n      }\n\n      // Adjust numbers and allocate storage and initialize fields.\n      strscale = Libbcmath.MIN(strscale, scale)\n      if (digits === 0) {\n        zeroInt = true\n        digits = 1\n      }\n\n      num = Libbcmath.bc_new_num(digits, strscale)\n\n      // Build the whole number.\n      ptr = 0 // str\n      if (str[ptr] === '-') {\n        num.n_sign = Libbcmath.MINUS\n        // (*num)->n_sign = MINUS;\n        ptr++\n      } else {\n        num.n_sign = Libbcmath.PLUS\n        // (*num)->n_sign = PLUS;\n        if (str[ptr] === '+') {\n          ptr++\n        }\n      }\n      while (str[ptr] === '0') {\n        ptr++ // Skip leading zeros.\n      }\n\n      nptr = 0 // (*num)->n_value;\n      if (zeroInt) {\n        num.n_value[nptr++] = 0\n        digits = 0\n      }\n      for (; digits > 0; digits--) {\n        num.n_value[nptr++] = Libbcmath.CH_VAL(str[ptr++])\n        //* nptr++ = CH_VAL(*ptr++);\n      }\n\n      // Build the fractional part.\n      if (strscale > 0) {\n        ptr++ // skip the decimal point!\n        for (; strscale > 0; strscale--) {\n          num.n_value[nptr++] = Libbcmath.CH_VAL(str[ptr++])\n        }\n      }\n\n      return num\n    },\n\n    cint: function (v) {\n      if (typeof v === 'undefined') {\n        v = 0\n      }\n      let x = parseInt(v, 10)\n      if (isNaN(x)) {\n        x = 0\n      }\n      return x\n    },\n\n    /**\n     * Basic min function\n     * @param {int} a\n     * @param {int} b\n     */\n    MIN: function (a, b) {\n      return a > b ? b : a\n    },\n\n    /**\n     * Basic max function\n     * @param {int} a\n     * @param {int} b\n     */\n    MAX: function (a, b) {\n      return a > b ? a : b\n    },\n\n    /**\n     * Basic odd function\n     * @param {int} a\n     */\n    ODD: function (a) {\n      return a & 1\n    },\n\n    /**\n     * replicate c function\n     * @param {array} r     return (by reference)\n     * @param {int} ptr\n     * @param {string} chr    char to fill\n     * @param {int} len       length to fill\n     */\n    memset: function (r, ptr, chr, len) {\n      let i\n      for (i = 0; i < len; i++) {\n        r[ptr + i] = chr\n      }\n    },\n\n    /**\n     * Replacement c function\n     * Obviously can't work like c does, so we've added an \"offset\"\n     * param so you could do memcpy(dest+1, src, len) as memcpy(dest, 1, src, len)\n     * Also only works on arrays\n     */\n    memcpy: function (dest, ptr, src, srcptr, len) {\n      let i\n      for (i = 0; i < len; i++) {\n        dest[ptr + i] = src[srcptr + i]\n      }\n      return true\n    },\n\n    /**\n     * Determine if the number specified is zero or not\n     * @param {bc_num} num    number to check\n     * @return boolean      true when zero, false when not zero.\n     */\n    bc_is_zero: function (num) {\n      let count // int\n      let nptr // int\n      // Quick check.\n      // if (num === BCG(_zero_)) return TRUE;\n      // Initialize\n      count = num.n_len + num.n_scale\n      nptr = 0 // num->n_value;\n      // The check\n      while (count > 0 && num.n_value[nptr++] === 0) {\n        count--\n      }\n\n      if (count !== 0) {\n        return false\n      } else {\n        return true\n      }\n    },\n\n    bc_out_of_memory: function () {\n      throw new Error('(BC) Out of memory')\n    },\n  }\n  return Libbcmath\n}\n"]}